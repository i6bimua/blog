<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MIT6-S081-LAB1 | i6bimua</title><meta name="author" content="i6bimua"><meta name="copyright" content="i6bimua"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="XV6 LABLab2: system calls前置知识首先还是学习前置的知识并且阅读源代码 proc结构体用于维护每个进程的状态等进程相关的信息 12345678910111213141516171819202122&#x2F;&#x2F; Per-process statestruct proc &#123;  struct spinlock lock;&#x2F;&#x2F; 自旋锁（1）  &#x2F;&#x2F; p-&gt;lock must">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6-S081-LAB1">
<meta property="og:url" content="https://i6biua.github.io/blog/2024/11/01/MIT6-S081-LAB1/index.html">
<meta property="og:site_name" content="i6bimua">
<meta property="og:description" content="XV6 LABLab2: system calls前置知识首先还是学习前置的知识并且阅读源代码 proc结构体用于维护每个进程的状态等进程相关的信息 12345678910111213141516171819202122&#x2F;&#x2F; Per-process statestruct proc &#123;  struct spinlock lock;&#x2F;&#x2F; 自旋锁（1）  &#x2F;&#x2F; p-&gt;lock must">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i6biua.github.io/blog/img/bg.jpg">
<meta property="article:published_time" content="2024-11-01T06:11:03.000Z">
<meta property="article:modified_time" content="2024-11-22T06:53:57.000Z">
<meta property="article:author" content="i6bimua">
<meta property="article:tag" content="C">
<meta property="article:tag" content="xv6">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i6biua.github.io/blog/img/bg.jpg"><link rel="shortcut icon" href="/blog/img/avatar.jpg"><link rel="canonical" href="https://i6biua.github.io/blog/2024/11/01/MIT6-S081-LAB1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MIT6-S081-LAB1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-22 14:53:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/img/bg.jpg')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="i6bimua"><span class="site-name">i6bimua</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MIT6-S081-LAB1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-01T06:11:03.000Z" title="发表于 2024-11-01 14:11:03">2024-11-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-22T06:53:57.000Z" title="更新于 2024-11-22 14:53:57">2024-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/OS/">OS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MIT6-S081-LAB1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/blog/img/bg.jpg)"></div><article class="post-content" id="article-container"><h1 id="XV6-LAB"><a href="#XV6-LAB" class="headerlink" title="XV6 LAB"></a>XV6 LAB</h1><h2 id="Lab2-system-calls"><a href="#Lab2-system-calls" class="headerlink" title="Lab2: system calls"></a>Lab2: system calls</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>首先还是学习前置的知识并且阅读源代码</p>
<p><strong>proc结构体</strong>用于维护每个进程的状态等进程相关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span><span class="comment">// 自旋锁（1）</span></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these: 因为可能有多个进程同时访问某个进程的这些状态变量</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan（2）</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held. 所以只有进程自己可以进行访问，不需要锁，最多同时被一个进程写</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S 用于陷阱处理</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process 用于内核上下文切换的被保存的寄存器。</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="知识点1-锁"><a href="#知识点1-锁" class="headerlink" title="知识点1 锁"></a>知识点1 锁</h5><h6 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h6><p>自旋锁具有忙等待的特性，一个线程获取了一个自旋锁后，另外一个线程期望获取该自旋锁，获取不到，只能够原地“打转”（忙等待）<br>所以自旋锁不应该被长时间的持有，否则会导致CPU资源的过度消耗                                                                                                                                                           自旋锁常用于中断上下文，因为在中断上下文中不可以使用会导致睡眠的锁</p>
<p><strong>为什么在中断上下文之中不可以睡眠</strong>：首先睡眠的含义是将进程置于“睡眠”状态，在这个状态的进程不能被调度执行。 然后，在一定的时机，这个进程可能会被重新置为“运行”状态，从而可能被调度 执行。 可见，“睡眠”与“运行”是针对进程而言的，代表进程的task_struct结构记录着进程的状态。 内核中的“调度器”通过task_struct对进 程进行调度。 但是，中断上下文却不是一个进程，它并不存在task_struct，所以它是不可调度的。 所以，<strong>在中断上下文不能睡眠</strong></p>
<h6 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h6><ol>
<li><p>悲观锁和乐观锁</p>
<p><strong>悲观锁</strong>是一种基于悲观态度的数据并发控制机制，用于防止数据冲突。它采取预防性的措施，在修改数据之前将其锁定，并在操作完成后释放锁定，以确保数据的一致性和完整性。悲观锁通常用于并发环境下的数据库系统，是数据库本身实现锁机制的一种方式。在悲观锁的机制下，当一个使用者要修改某个数据时，首先会尝试获取该数据的锁。如果锁已经被其他使用者持有，则当前使用者会被阻塞，直到对应的锁被释放。这种悲观的态度认为数据冲突是不可避免的，因此在修改数据之前先锁定数据，以防止冲突的发生。</p>
<p><strong>乐观锁</strong>是一种基于版本控制的并发控制机制。在乐观锁的思想中，认为数据访问冲突的概率很低，因此不加锁直接进行操作，但在更新数据时会进行版本比对，以确保数据的一致性。乐观锁的原理主要基于版本号或时间戳来实现。在每次更新数据时，先获取当前数据的版本号或时间戳，然后在更新时比对版本号或时间戳是否一致，若一致则更新成功，否则表示数据已被其他线程修改，更新失败。</p>
<p>e.g. CAS(Compare and Swap)</p>
<p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。</p>
</li>
</ol>
<p>​	悲观锁适合写操作多的场景，乐观锁适合读操作多的场景，乐观锁的吞吐量会比悲观锁多</p>
<ol start="2">
<li><p>公平锁和非公平锁</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/115543000">公平锁与非公平锁区别知乎专栏</a></p>
<p><strong>公平锁</strong>：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<ul>
<li>优点：所有的线程都能得到资源，不会饿死在队列中。</li>
<li>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</li>
</ul>
<p><strong>非公平锁</strong>：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<ul>
<li>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</li>
<li>缺点：可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</li>
</ul>
</li>
<li><p>独享锁（互斥锁）和共享锁</p>
<p><strong>独享锁</strong>（互斥锁）：独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排他锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</p>
<p><strong>共享锁：<strong>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过</strong>AQS</strong>来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2425999">AQS概述</a></p>
</li>
<li><p>可重入锁和不可重入锁</p>
<p><strong>可重入锁</strong>：当线程获取某个锁后，还可以继续获取它，可以递归调用，而不会发生死锁；</p>
<p><strong>不可重入锁</strong>：与可重入相反，获取锁后不能重复获取，否则会死锁（自己锁自己）。</p>
</li>
<li><p>自旋锁，分段锁，死锁</p>
<p>自旋锁不会发生线程状态的切换：一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p><strong>分段锁</strong>： 并不是具体的一种锁，只是一种锁的设计，将数据分段上锁，把锁进一步细粒度化，可以提升并发量。当操作不需要更新整个数组的时候，就仅针对数组中的一项进行加锁操作</p>
<p><strong>死锁</strong>：两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法让程序进行下去</p>
</li>
</ol>
<h5 id="知识点2-chan"><a href="#知识点2-chan" class="headerlink" title="知识点2 chan"></a>知识点2 chan</h5><p><code>chan</code> 是一个指向任意类型数据的指针。它通常用于标识进程正在等待的具体资源或条件。当一个进程调用 <code>sleep</code> 函数时，它会传递一个 <code>chan</code> 参数，这个参数可以是任何类型的指针，比如指向某个文件、设备、内存区域等的指针。</p>
<p><code>chan</code> 的主要作用是在唤醒进程时使用。当其他进程（或中断处理程序）完成了一定的工作，需要唤醒因等待该资源而休眠的进程时，它会调用相应的唤醒函数，并传入相同的 <code>chan</code> 值。操作系统内核会检查所有处于睡眠状态的进程，如果发现有进程的 <code>chan</code> 与传入的 <code>chan</code> 匹配，则将该进程从睡眠状态唤醒。</p>
<p>通过这种方式，<code>chan</code> 能够确保只有那些真正等待特定资源或事件的进程会被唤醒，从而提高了系统的效率和响应性。</p>
<p>后面的lab里面应该有所涉及，不过也可以提前看看<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38616705/article/details/108610236">这篇文章</a></p>
<p>RISC-V计算机上电的时候会初始化自己并且运行一个存储在ROM中的引导加载程序，将xv6的kernel加载到内存中。然后在机器模式下中央处理器从_entry开始运行xv6。起始位置为0x80000000，因为0x0：0x80000000包含I&#x2F;O设备</p>
<p><code>_entry</code>的指令设置了一个栈区，这样xv6就可以运行C代码。Xv6在<strong>start. c (kernel&#x2F;start.c:11)<strong>文件中为初始栈</strong>stack0</strong>声明了空间。由于RISC-V上的栈是向下扩展的，所以<code>_entry</code>的代码将栈顶地址<code>stack0+4096</code>加载到栈顶指针寄存器<code>sp</code>中。现在内核有了栈区，<code>_entry</code>便调用C代码<code>start</code>(<strong>kernel&#x2F;start.c</strong>:21)。</p>
<p><strong>entry.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	# qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each CPU to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">_entry:</span><br><span class="line">	# set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0 // load address 将sp加载为stack0的地址</span><br><span class="line">        li a0, 1024*4 // load immediate 将a0设置为4096（4KB）</span><br><span class="line">	csrr a1, mhartid // 从 mhartid 寄存器读取当前硬件线程ID（HART ID），并将其存储在 a1 中。</span><br><span class="line">        addi a1, a1, 1 // 保证栈偏移量不为0,不能向负地址减少</span><br><span class="line">        mul a0, a0, a1 // 计算出了当前CPU的栈偏移量</span><br><span class="line">        add sp, sp, a0 // 将计算出的栈偏移量加到栈指针 sp 上，从而为每个CPU分配独立的栈空间</span><br><span class="line">	# jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin // 说明start程序返回了，那么进入无限循环，防止CPU继续执行无效指令</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>start.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timerinit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="type">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br><span class="line"></span><br><span class="line"><span class="comment">// scratch area for timer interrupt, one per CPU.</span></span><br><span class="line">uint64 mscratch0[NCPU * <span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// assembly code in kernelvec.S for machine-mode timer interrupt.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">timervec</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry.S jumps here in machine mode on stack0.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// set M Previous Privilege mode to Supervisor, for mret.</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_mstatus();<span class="comment">// 读取mstatus寄存器的值</span></span><br><span class="line">  x &amp;= ~MSTATUS_MPP_MASK;<span class="comment">//清除MPP字段,表示机器模式之前的特权模式</span></span><br><span class="line">  x |= MSTATUS_MPP_S;<span class="comment">//设置MPP字段为S(Supervisor mode)</span></span><br><span class="line">  w_mstatus(x);<span class="comment">//写会mstatus</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set M Exception Program Counter to main, for mret.</span></span><br><span class="line">  <span class="comment">// requires gcc -mcmodel=medany</span></span><br><span class="line">  w_mepc((uint64)main);<span class="comment">//将 mepc 寄存器设置为 main 函数的地址。mepc 寄存器用于存储异常返回时的程序计数器（PC）值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// disable paging for now.</span></span><br><span class="line">  w_satp(<span class="number">0</span>);<span class="comment">//禁用虚拟地址转换</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// delegate all interrupts and exceptions to supervisor mode.</span></span><br><span class="line">  w_medeleg(<span class="number">0xffff</span>);<span class="comment">//medeleg 寄存器用于指定哪些异常类型应该由监督模式处理</span></span><br><span class="line">  w_mideleg(<span class="number">0xffff</span>);<span class="comment">//mideleg 寄存器用于指定哪些中断类型应该由监督模式处理</span></span><br><span class="line">    <span class="comment">// 0xffff表示所有的异常类型和中断类型都委托给监督模式处理</span></span><br><span class="line">  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for clock interrupts.</span></span><br><span class="line">  timerinit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span></span><br><span class="line">  <span class="type">int</span> id = r_mhartid();</span><br><span class="line">  w_tp(id);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// switch to supervisor mode and jump to main().</span></span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mret&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">//mret执行返回，返回到先前状态，由于start函数将前模式改为了管理模式且返回地址改为了main,因此mret将返回到main函数，并以管理模式运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>main</code>(<strong>kernel&#x2F;main.c</strong>:11)初始化几个设备和子系统后，便通过调用<code>userinit</code> (<strong>kernel&#x2F;proc.c</strong>:212)创建第一个进程，第一个进程执行一个用RISC-V程序集写的小型程序：<strong>initcode. S</strong> (**user&#x2F;initcode.S:**1)，它通过调用<code>exec</code>系统调用重新进入内核。正如我们在第1章中看到的，<code>exec</code>用一个新程序（本例中为 <code>/init</code>）替换当前进程的内存和寄存器。一旦内核完成<code>exec</code>，它就返回<code>/init</code>进程中的用户空间。如果需要，<code>init</code>(<strong>user&#x2F;init.c</strong>:15)将创建一个新的控制台设备文件，然后以文件描述符0、1和2打开它。然后它在控制台上启动一个shell。系统就这样启动了。</p>
<p><strong>initcode. S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Initial process that execs /init.</span><br><span class="line"># This code runs in user space.</span><br><span class="line"></span><br><span class="line">#include &quot;syscall.h&quot;</span><br><span class="line"></span><br><span class="line"># exec(init, argv)</span><br><span class="line">.globl start //将start声明为全局符号,使其在链接是可见</span><br><span class="line">start://程序入口</span><br><span class="line">        la a0, init // 将 init 字符串的地址加载到寄存器 a0 中</span><br><span class="line">        la a1, argv // 将 argv 数组的地址加载到寄存器 a1 中</span><br><span class="line">        li a7, SYS_exec // 将SYS_exec系统调用号加载到寄存器中</span><br><span class="line">        ecall // 触发系统调用,执行exec</span><br><span class="line"></span><br><span class="line"># for(;;) exit();</span><br><span class="line">exit:</span><br><span class="line">        li a7, SYS_exit</span><br><span class="line">        ecall</span><br><span class="line">        jal exit</span><br><span class="line"></span><br><span class="line"># char init[] = &quot;/init\0&quot;;</span><br><span class="line">init: //init 标签指向字符串 /init\0 的起始地址</span><br><span class="line">  .string &quot;/init\0&quot;</span><br><span class="line"></span><br><span class="line"># char *argv[] = &#123; init, 0 &#125;;</span><br><span class="line">.p2align 2 //将 argv 数组的地址对齐到4字节边界</span><br><span class="line">argv:</span><br><span class="line">  .long init // init字符串的地址作为第一个元素</span><br><span class="line">  .long 0 // 0作为第二个元素表示参数列表的结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="源代码阅读"><a href="#源代码阅读" class="headerlink" title="源代码阅读"></a>源代码阅读</h3><ul>
<li>系统调用的用户空间代码在<strong>user&#x2F;user.h</strong>和<strong>user&#x2F;usys.pl</strong>中。</li>
<li>内核空间代码是<strong>kernel&#x2F;syscall.h</strong>、<strong>kernel&#x2F;syscall.c</strong>。</li>
<li>与进程相关的代码是<strong>kernel&#x2F;proc.h</strong>和<strong>kernel&#x2F;proc.c</strong>。</li>
</ul>
<p><strong>user&#x2F;user.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个其实在很早之前就看了一遍了,但是再看一遍也无妨</span></span><br><span class="line"><span class="comment">#define T_DIR     1   // Directory</span></span><br><span class="line"><span class="comment">#define T_FILE    2   // File</span></span><br><span class="line"><span class="comment">#define T_DEVICE  3   // Device</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">struct stat &#123;</span></span><br><span class="line"><span class="comment">  int dev;     // 文件系统所在的磁盘设备编号,标识文件所属的文件系统所在的物理设备</span></span><br><span class="line"><span class="comment">  uint ino;    // Inode number</span></span><br><span class="line"><span class="comment">  short type;  // Type of file</span></span><br><span class="line"><span class="comment">  short nlink; // Number of links to file,硬链接就是文件系统中对于同一个inode的引用</span></span><br><span class="line"><span class="comment">  			   // 类似inode为3的文件可以有一个名字是a,另一个名字是b,都指向同一个文件</span></span><br><span class="line"><span class="comment">  uint64 size; // Size of file in bytes</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtcdate</span>;</span><span class="comment">//用于存储实时钟（RTC，Real-Time Clock）的时间和日期信息,通常用于记录当前的时间和日期</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct rtcdate &#123;</span></span><br><span class="line"><span class="comment">  uint second;</span></span><br><span class="line"><span class="comment">  uint minute;</span></span><br><span class="line"><span class="comment">  uint hour;</span></span><br><span class="line"><span class="comment">  uint day;</span></span><br><span class="line"><span class="comment">  uint month;</span></span><br><span class="line"><span class="comment">  uint year;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 创建一个新的进程,返回值是pid</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>; <span class="comment">// 不会返回,状态码表示退出状态</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>; <span class="comment">// 等待子进程结束并且获取其退出状态,出错返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>; <span class="comment">// 出错返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">char</span>*, <span class="type">char</span>**)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">short</span>, <span class="type">short</span>)</span>;<span class="comment">//mknod(const char *path, short mode, short dev)</span></span><br><span class="line"><span class="comment">//创建特殊文件（如设备文件），path 是文件路径，mode 是文件类型和权限，dev 是设备号。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;<span class="comment">//删除文件或者符号链接</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat*)</span>;<span class="comment">//获取文件描述符fd对应的文件的状态信息,存储在st中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;<span class="comment">//link(const char *oldpath, const char *newpath)</span></span><br><span class="line"><span class="comment">//创建硬链接，oldpath 是现有文件路径，newpath 是新链接路径。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;<span class="comment">//改变当前工作目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;<span class="comment">//复制文件描述符,返回一个新的文件描述符</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">char* sbrk(int increment)</span></span><br><span class="line"><span class="comment">@brief 调整数据段的大小，increment 是增加或减少的字节数。</span></span><br><span class="line"><span class="comment">@return 成功返回新的数据段起点地址，出错返回 (char*)-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">//获取系统自启动以来的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ulib.c 标准库函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="keyword">struct</span> stat*)</span>;<span class="comment">//通过文件路径获取文件状态信息</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memmove</span><span class="params">(<span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;<span class="comment">//复制多少个字节到另一个区域,允许重叠</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">char</span> c)</span>;<span class="comment">//在一个字符串中寻找字符c的第一次出现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@return 负数 s1&lt;s2</span></span><br><span class="line"><span class="comment">        0   s1=s2</span></span><br><span class="line"><span class="comment">        正数 s1&gt;s2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fprintf</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">char</span>*, ...)</span>;、、写入文件</span><br><span class="line"><span class="type">void</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, ...)</span>;</span><br><span class="line"><span class="type">char</span>* <span class="title function_">gets</span><span class="params">(<span class="type">char</span>*, <span class="type">int</span> max)</span>;<span class="comment">//从标准输入读取一行字符串,最多读取max个字符</span></span><br><span class="line">uint <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">memset</span><span class="params">(<span class="type">void</span>*, <span class="type">int</span>, uint)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(uint)</span>;<span class="comment">//返回指向分配内存的指针</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *, uint)</span>;<span class="comment">//比较内存区域的前n个字节</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *, uint)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>user&#x2F;usys.pl</strong></p>
<p>.pl文件是Perl脚本语言的文件(Perl是UNIX的通用脚本语言)</p>
<p>脚本语言其实就是类似于Python一样的由解释器直接进行解释而并不需要经过编译再进行执行的语言</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl -w</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate usys.S, the stubs for syscalls.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">entry</span> </span>&#123;//entry子程序接收一个参数<span class="variable">$name</span>，即系统调用的名字。它生成对应的汇编代码</span><br><span class="line">    <span class="keyword">my</span> <span class="variable">$name</span> = <span class="keyword">shift</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;.global <span class="variable">$name</span>\n&quot;</span>; <span class="regexp">//</span>声明符号为全局可见,以便其他文件可以引用</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;<span class="subst">$&#123;name&#125;</span>:\n&quot;</span>;<span class="regexp">//</span>定义一个标签表示函数入口点</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; li a7, SYS_<span class="subst">$&#123;name&#125;</span>\n&quot;</span>; <span class="regexp">//</span>加载系统调用编号到寄存器a7</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ecall\n&quot;</span>;<span class="regexp">//</span>发出系统调用指令</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot; ret\n&quot;</span>;<span class="regexp">//</span>返回到调用者</span><br><span class="line">&#125;</span><br><span class="line">// 对于每一个列出的系统调用名称，调用一次entry子程序来生成相应的汇编代码</span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>kernel&#x2F;syscall.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers 给每个系统调用分配一个数字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br></pre></td></tr></table></figure>

<p><strong>kernel&#x2F;syscall.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;syscall.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fetchaddr</span><span class="params">(uint64 addr, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= p-&gt;sz || addr+<span class="built_in">sizeof</span>(uint64) &gt; p-&gt;sz) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">copyin</span>(p-&gt;pagetable, (<span class="type">char</span> *)ip, addr, <span class="built_in">sizeof</span>(*ip)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">copyinstr</span>(p-&gt;pagetable, buf, addr, max);</span><br><span class="line">  <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">argraw</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = <span class="built_in">argraw</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = <span class="built_in">argraw</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(n, &amp;addr) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fetchstr</span>(addr, buf, max);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// extern 关键字表示这些函数是在其他地方定义的，当前文件只需要知道它们的存在和签名即可</span></span><br><span class="line"><span class="comment">// 此处extern只是对于变量的声明而不是定义,因为只能有一次定义</span></span><br><span class="line"><span class="comment">// 将变量/函数声明为extern就可以在另一个文件中用extern定义变量/函数,并且在所提前声明的文件中使用</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_chdir</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_close</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_dup</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_exec</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_exit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_fstat</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_kill</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_link</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_mknod</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_open</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_pipe</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_read</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_unlink</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_wait</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_write</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> uint64 <span class="title">sys_uptime</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static表示数组只在当前文件中可见</span></span><br><span class="line"><span class="comment">// 下面声明了一个函数指针数组syscalls , 每个元素都是一个返回值为uint64类型值的函数指针</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// syscall为数组名</span></span><br><span class="line">    <span class="comment">// [] 表示这是一个数组</span></span><br><span class="line">    <span class="comment">// (*syscalls[]) 表示数组的每个元素都是一个函数指针,类似int* a[]</span></span><br><span class="line">    <span class="comment">// 函数指针形如 return_type (*pointer_name)(parameter_list);</span></span><br><span class="line">    <span class="comment">// (void) 表示这些函数指针指向的函数不接受任何参数</span></span><br><span class="line">[SYS_fork]    sys_fork,<span class="comment">//将sys_fork的地址赋值给syscalls数组中索引为SYS_for的位置</span></span><br><span class="line">    <span class="comment">//syscall 函数接收系统调用号 num 和最多六个参数 a0 到 a5,这些参数会被传递给相应的系统调用处理函数</span></span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Memory-Management-Unit-MMU-是虚拟内存管理的关键-页表是MMU的核心组成部分，它维护了虚拟地址与物理地址之间的映射关系。"><a href="#Memory-Management-Unit-MMU-是虚拟内存管理的关键-页表是MMU的核心组成部分，它维护了虚拟地址与物理地址之间的映射关系。" class="headerlink" title="Memory Management Unit (MMU)是虚拟内存管理的关键,页表是MMU的核心组成部分，它维护了虚拟地址与物理地址之间的映射关系。"></a><strong>Memory Management Unit (MMU)是虚拟内存管理的关键,页表是MMU的核心组成部分，它维护了虚拟地址与物理地址之间的映射关系。</strong></h6><p>fetchaddr()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the uint64 at addr from the current process.</span></span><br><span class="line"><span class="comment">// 从当前进程的地址空间读取一个位于addr位置的uint64类型的数据</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fetchaddr</span><span class="params">(uint64 addr, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();<span class="comment">//proc是用于维护每个进程的状态等进程相关的信息的结构</span></span><br><span class="line">    <span class="comment">//确保addr不超过进程的内存大小,确保从 addr 开始的 sizeof(uint64) 字节都在进程的内存范围内</span></span><br><span class="line">  <span class="keyword">if</span>(addr &gt;= p-&gt;sz || addr+<span class="built_in">sizeof</span>(uint64) &gt; p-&gt;sz) <span class="comment">// sz为以字节为单位进程内存的大小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//从进程的地址空间中复制 sizeof(uint64) 字节的数据到内核空间的 ip 指针所指向的位置</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">copyin</span>(p-&gt;pagetable, (<span class="type">char</span> *)ip, addr, <span class="built_in">sizeof</span>(*ip)) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>myproc()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return the current struct proc *, or zero if none.</span></span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">proc</span>*</span><br><span class="line">   <span class="built_in">myproc</span>(<span class="type">void</span>) &#123;</span><br><span class="line">     <span class="built_in">push_off</span>();<span class="comment">//关闭中断,保证操作的原子性,防止被其他进程抢占</span></span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">proc</span> *p = c-&gt;proc;</span><br><span class="line">     <span class="built_in">pop_off</span>();<span class="comment">//恢复中断</span></span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>push_off()和pop_off()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">push_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="type">int</span> old = <span class="built_in">intr_get</span>();<span class="comment">//获取当前的中断状态</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">intr_off</span>();<span class="comment">//关闭中断,保证不会被强抢占</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;noff == <span class="number">0</span>)<span class="comment">//noff计数器为0表示是第一次调用push_off()</span></span><br><span class="line">        <span class="built_in">mycpu</span>()-&gt;intena = old;<span class="comment">//将当前的中断状态保存到mycpu()-&gt;intena中</span></span><br><span class="line">      <span class="built_in">mycpu</span>()-&gt;noff += <span class="number">1</span>;<span class="comment">//增加嵌套计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function">    <span class="title">pop_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">intr_get</span>()) <span class="comment">//如果此时是允许中断状态,说明push_off没有正确的关闭中断</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)<span class="comment">//说明pop_off调用次数超过push_off,出现了问题</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">      c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)<span class="comment">//恢复最初的状态,如果最初保存的状态是允许中断就恢复中断,否则保持不允许中断的状态</span></span><br><span class="line">        <span class="built_in">intr_on</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>copyin（）函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// Copy from user to kernel.</span></span><br><span class="line">  <span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line">  <span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  @param</span></span><br><span class="line"><span class="comment">      pagetable：用户空间的页表</span></span><br><span class="line"><span class="comment">      dst：内核空间的目标地址</span></span><br><span class="line"><span class="comment">      srcva：用户空间的源地址(此处是一个虚拟地址virtual address)</span></span><br><span class="line"><span class="comment">      len：要复制的字节数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">  <span class="title">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line">    <span class="comment">//n：当前页中要复制的字节数。</span></span><br><span class="line">    <span class="comment">//va0：当前页的起始虚拟地址。(va: virtual address)</span></span><br><span class="line">    <span class="comment">//pa0：当前页的物理地址。(pa:physical address)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      va0 = <span class="built_in">PGROUNDDOWN</span>(srcva);<span class="comment">//当前页的起始虚拟地址</span></span><br><span class="line">      </span><br><span class="line">      pa0 = <span class="built_in">walkaddr</span>(pagetable, va0);<span class="comment">//根据va0查找当前页的物理地址</span></span><br><span class="line">    	</span><br><span class="line">      <span class="keyword">if</span>(pa0 == <span class="number">0</span>)<span class="comment">//页表中没有找到对应的物理地址</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      n = PGSIZE - (srcva - va0);<span class="comment">//当前页中从 srcva 开始的剩余字节数</span></span><br><span class="line">      <span class="keyword">if</span>(n &gt; len)<span class="comment">//如果剩余字节数大于要复制的总字节数 len，则只复制 len 个字节</span></span><br><span class="line">        n = len;</span><br><span class="line">        <span class="comment">//memmove 函数将从物理地址 (pa0 + (srcva - va0)) 开始的 n 个字节复制到内核空间的 dst 地址</span></span><br><span class="line">        <span class="comment">//这里的(pa0 + (srcva - va0))其实就是将物理地址pa0加上了页内偏移量(srcva-va0)</span></span><br><span class="line">        <span class="comment">//这就是计组中对于拼接高52位页表项得到的物理地址高位和低12位页内偏移量得到实际物理地址的方法</span></span><br><span class="line">        <span class="comment">//具体应该在虚拟内存章节</span></span><br><span class="line">      <span class="built_in">memmove</span>(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line"></span><br><span class="line">      len -= n;</span><br><span class="line">      dst += n;</span><br><span class="line">      srcva = va0 + PGSIZE;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      减少剩余字节数：len -= n 减少剩余要复制的字节数</span></span><br><span class="line"><span class="comment">移动目标指针：dst += n 移动目标指针到下一个位置,因为已经复制了n个字节,所以对应的目标地址也改变</span></span><br><span class="line"><span class="comment">移动源指针：srcva = va0 + PGSIZE 移动源指针到下一页的起始地址</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h6 id="PGROUNDDOWN-PGROUNDUP的解释"><a href="#PGROUNDDOWN-PGROUNDUP的解释" class="headerlink" title="PGROUNDDOWN&amp;PGROUNDUP的解释"></a>PGROUNDDOWN&amp;PGROUNDUP的解释</h6><p> #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))<br>#define PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))<br>考虑PGROUNDDOWN(a)<br>PGSIZE通常是一个2的幂次，xv6中是4096-&gt;2^12，即<br>原数二进制表示：    0001_0000_0000_0000<br>~(PGSIZE-1))则为：1111_0000_0000_0000</p>
<p>将a与之相 &amp; 其实就是保留了高四位<br>可以认为是将一个页中表示 页内地址 的低12位都置为0，所以就是页的第0个地址，也就是页起始地址<br>因为每一个页大小为2^12所以从第LSB向左数的第13位开始其实就类似于计组一样，在这里我把它当做类似于页号一样的东西，会发现其实第一个页起始地址高四位是0001，剩下都是0，而第二个页开始就是0010，后面都是0，高四位其实就是（页号-1），和计组有相似之处。</p>
<p>e.g.        </p>
<p>​        PGROUNDUP(620) &#x3D;&#x3D;&gt; ((620 + (1024 -1)) &amp; ~(1023)) &#x3D;&#x3D;&gt; 1024<br>​        地址 620 被四舍五入为 1024。<br>​        同样PGROUNDDOWN考虑：<br>​        PGROUNDDOWN(2400) &#x3D;&#x3D;&gt; (2400 &amp; ~(1023)) &#x3D;&#x3D;&gt; 2048<br>​        地址 2400 向下舍入为 2048。<br>​        附赠stackoverflow的回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43289022/what-do-pgroundup-and-pgrounddown-in-xv6-mean">https://stackoverflow.com/questions/43289022/what-do-pgroundup-and-pgrounddown-in-xv6-mean</a></p>
<p>walkaddr()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Look up a virtual address, return the physical address,</span></span><br><span class="line">        <span class="comment">// or 0 if not mapped.</span></span><br><span class="line">        <span class="comment">// Can only be used to look up user pages.</span></span><br><span class="line">        <span class="comment">// 查找虚拟地址对应的物理地址</span></span><br><span class="line">        @param </span><br><span class="line">            pagetable：页表的根节点</span><br><span class="line">            va：要查找的虚拟地址</span><br><span class="line">        <span class="function">uint64</span></span><br><span class="line"><span class="function">        <span class="title">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="type">pte_t</span> *pte; <span class="comment">// 指向页表项的指针</span></span><br><span class="line">          uint64 pa; <span class="comment">// 物理地址</span></span><br><span class="line">		  <span class="comment">//#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</span></span><br><span class="line">          <span class="keyword">if</span>(va &gt;= MAXVA)<span class="comment">//确保虚拟地址在有效的范围之内</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		  <span class="comment">//walk 函数根据虚拟地址 va 和页表 pagetable 查找对应的页表项</span></span><br><span class="line">          pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span>(pte == <span class="number">0</span>)<span class="comment">//没有找到对应的页表项</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)<span class="comment">//PTE_V是页表中的有效位（valid），确保该页表项是有效的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)<span class="comment">//PTE_U是页表项中的用户访问位。如果 PTE_U 为 0，表示该页表项不能被用户访问</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">            <span class="comment">// #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line">            <span class="comment">// 将页表项中的物理地址部分提取出来得到实际的物理地址</span></span><br><span class="line">            <span class="comment">// 页表项中的低10位用于表示属性，所以先清除，保留52位的物理地址部分</span></span><br><span class="line">            <span class="comment">// 然后左移12位用于对齐到页边界，因为低12位表示页内偏移量</span></span><br><span class="line">            <span class="comment">// 在计组中提到物理地址和虚拟地址的页内偏移量是相同的</span></span><br><span class="line">          <span class="keyword">return</span> pa;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>walk()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index. 因为512=2^9所以需要9位保存页表索引</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param</span></span><br><span class="line"><span class="comment">    pagetable：页表的根节点</span></span><br><span class="line"><span class="comment">    va：要查找的虚拟地址</span></span><br><span class="line"><span class="comment">    alloc：是否在找不到页表项时创建新的页表页</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)<span class="comment">//确保虚拟地址在有效的范围内</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有三级页表,分别对应L2,L1和L0层</span></span><br><span class="line"><span class="comment">    L2 层索引：用于查找 L1 页表的基地址</span></span><br><span class="line"><span class="comment">	L1 层索引：用于查找 L0 页表的基地址</span></span><br><span class="line"><span class="comment">	L0 层索引：用于查找物理页框的基地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[<span class="built_in">PX</span>(level, va)];<span class="comment">//计算当前层次的页表索引,获取对应的的页表项指针</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="comment">      #define PXMASK          0x1FF // 9 bits 用于提取最右边的9位(低9位)</span></span><br><span class="line"><span class="comment">      #define PXSHIFT(level)  (PGSHIFT+(9*(level))) 计算虚拟地址宏对应层次的页表索引的偏移量</span></span><br><span class="line"><span class="comment">      这里所说的“偏移量”是位数的偏移量，并且后面提到的参数在代码段最上方的注释中有写明</span></span><br><span class="line"><span class="comment">      PGSHIFT是页内偏移的位移量,为12位</span></span><br><span class="line"><span class="comment">      9*(level)g根据层次level计算额外的位移量，因为每一级页表索引占用9位</span></span><br><span class="line"><span class="comment">      #define PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br><span class="line"><span class="comment">      将虚拟地址右移特定位数以使得所需的对应页表索引位位于最低的9位</span></span><br><span class="line"><span class="comment">      然后与PXMASK相 &amp; 得到最低的9位得到页表索引</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)<span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">        <span class="comment">// #define PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)</span><br><span class="line">          <span class="comment">// 使用kalloc分配新的页表页</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);<span class="comment">//初始化新的页表页</span></span><br><span class="line">      *pte = <span class="built_in">PA2PTE</span>(pagetable) | PTE_V;<span class="comment">//将新分配的页表页的物理地址转换为页表项格式，并设置有效位 PTE_V</span></span><br><span class="line">        <span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line">		<span class="comment">//#define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line">        <span class="comment">// 先去除页内偏移量然后预留10位来表示属性信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 遍历完成后，pagetable 指向 L0 层的页表，返回对应的页表项指针</span></span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[<span class="built_in">PX</span>(<span class="number">0</span>, va)];<span class="comment">//返回 L0 层的页表项指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fetchchstr()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// 获取一个以nul结尾的字符串</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="type">int</span> err = <span class="built_in">copyinstr</span>(p-&gt;pagetable, buf, addr, max);</span><br><span class="line">    <span class="comment">// copyinstr()函数的逻辑和上面copyin函数的逻辑基本相同,只添加了一个是否发现&#x27;\0&#x27;字符的判断</span></span><br><span class="line">  <span class="keyword">if</span>(err &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);<span class="comment">//返回字符串的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argraw（）函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前进程的陷阱帧中获取系统调用参数的原始值</span></span><br><span class="line"><span class="comment">// 参考:https://zhuanlan.zhihu.com/p/634222367</span></span><br><span class="line"><span class="comment">// 陷阱帧包含从内核返回到当前进程时恢复用户模式所需的所有寄存器信息，以便处理器可以像陷阱启动时一样继续运行</span></span><br><span class="line"><span class="function"><span class="type">static</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">argraw</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">    <span class="comment">//返回相应的寄存器值,寄存器 a0 到 a5 通常用于传递系统调用的参数</span></span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argint()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="comment">// 取回 第n个 32位的系统调用的参数</span></span><br><span class="line"><span class="comment">// e.g. ssize_t sys_write(int fd, const void *buf, size_t count);</span></span><br><span class="line"><span class="comment">// n=0是第一个参数fd,n=1...以此类推</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = <span class="built_in">argraw</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argaddr（）函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Retrieve an argument as a pointer. 将参数作为指针值返回</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since 不检查指针的合法性，因为copin、copyout函数会进行检查</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *ip = <span class="built_in">argraw</span>(n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>argstr()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// 需要注意这里是将参数作为一个和字长的长度相同的字符串</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(n, &amp;addr) &lt; <span class="number">0</span>) <span class="comment">// 检查是否合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fetchstr</span>(addr, buf, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>syscall()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7; <span class="comment">// 从陷阱帧中获取系统调用号</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">      <span class="comment">// #define NELEM(x) (sizeof(x)/sizeof((x)[0]))</span></span><br><span class="line">      <span class="comment">// 检查系统调用号是否在有效范围内并且检查syscalls数组中对应项是否为非空</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">      <span class="comment">//调用系统调用并且将返回值保存在陷阱帧的a0寄存器中</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;<span class="comment">//表示系统调用失败</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>kernel&#x2F;proc.h</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="comment">// 保存内核上下文切换时需要保存的寄存器值,用于在进程切换或中断处理过程中保存和恢复寄存器的值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">context</span> &#123;</span><br><span class="line">    uint64 ra; <span class="comment">// 返回地址寄存器</span></span><br><span class="line">    uint64 sp; <span class="comment">// 栈指针寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// callee-saved 被调用者保存寄存器</span></span><br><span class="line">    uint64 s0;</span><br><span class="line">    uint64 s1;</span><br><span class="line">    uint64 s2;</span><br><span class="line">    uint64 s3;</span><br><span class="line">    uint64 s4;</span><br><span class="line">    uint64 s5;</span><br><span class="line">    uint64 s6;</span><br><span class="line">    uint64 s7;</span><br><span class="line">    uint64 s8;</span><br><span class="line">    uint64 s9;</span><br><span class="line">    uint64 s10;</span><br><span class="line">    uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="comment">// 每个CPU的状态</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *proc;      <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> context; <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">    						<span class="comment">// 在 swtch() 函数中使用这个变量来进入调度器</span></span><br><span class="line">    <span class="type">int</span> noff;               <span class="comment">// Depth of push_off() nesting. 计数器</span></span><br><span class="line">    <span class="type">int</span> intena;             <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">    <span class="comment">// 其实就是保存中断嵌套中第一次中断前是否允许中断</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> <span class="title class_">cpu</span> cpus[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个进程的数据，用于 trampoline.S 中的中断处理代码。</span></span><br><span class="line"><span class="comment">// 存储在一个单独的页面中，位于 trampoline 页面下方，在用户页表中。不在内核页表中特别映射。</span></span><br><span class="line"><span class="comment">// sscratch 寄存器指向这里。</span></span><br><span class="line"><span class="comment">// uservec 在 trampoline.S 中保存用户寄存器到 trapframe，</span></span><br><span class="line"><span class="comment">// 然后从 trapframe 初始化寄存器，包括 kernel_sp, kernel_hartid, kernel_satp，并跳转到 kernel_trap。</span></span><br><span class="line"><span class="comment">// usertrapret() 和 userret 在 trampoline.S 中设置 trapframe 的 kernel_* 字段，</span></span><br><span class="line"><span class="comment">// 恢复用户寄存器从 trapframe，切换到用户页表，并进入用户空间。</span></span><br><span class="line"><span class="comment">// trapframe 包括被调用者保存的用户寄存器（如 s0-s11），因为通过 usertrapret() 返回用户路径时，</span></span><br><span class="line"><span class="comment">// 不会返回整个内核调用堆栈。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">uservec 是一个汇编函数，位于 trampoline.S 文件中。它负责保存用户态寄存器到 trapframe，然后初始化内核态寄存器（如 kernel_sp, kernel_hartid, kernel_satp），并跳转到 kernel_trap 函数</span></span><br><span class="line"><span class="comment">usertrapret() 和 userret 也是汇编函数，位于 trampoline.S 文件中。它们负责设置 trapframe 的内核字段，恢复用户态寄存器，切换到用户页表，并重新进入用户态</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">trapframe</span> &#123;</span><br><span class="line">   <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// 内核页表的地址</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// 进程的内核栈顶地址</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap() 函数地址,用于处理用户态的中断</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// 保存的用户程序计数器,中断发生时的指令地址</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// 保存的内核 tp 寄存器,用于标识处理器核心</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;            <span class="comment">// 返回地址寄存器,保存中断处理结束后的返回地址</span></span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;            <span class="comment">// 用户栈指针</span></span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;            <span class="comment">// 全局指针</span></span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;            <span class="comment">// 线程指针</span></span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;            <span class="comment">// 临时寄存器</span></span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;            </span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;            </span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;            <span class="comment">// 被调用者保存寄存器,用于保存函数调用过程中需要保留的值</span></span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;            </span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;            <span class="comment">// 参数寄存器</span></span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;            </span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;            </span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;            </span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;            </span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;            </span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;            </span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;            <span class="comment">//（通常用于系统调用号）</span></span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;            <span class="comment">// 被调用者保存寄存器</span></span><br><span class="line">  <span class="comment">// 被调用者保存寄存器在函数调用过程中需要由被调用函数负责保存和恢复</span></span><br><span class="line">  <span class="comment">// 调用者保存寄存器的值在函数调用过程中由调用者负责保存和恢复。</span></span><br><span class="line">  <span class="comment">// 被调用函数在进入时会保存这些寄存器的值，然后在返回前恢复这些值</span></span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;            </span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;            </span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;            </span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;            </span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;            </span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;            </span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;            </span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;           </span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;           </span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;            <span class="comment">// 临时寄存器</span></span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;            </span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;            </span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;            </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">procstate</span> &#123; UNUSED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br><span class="line"><span class="comment">// 进程的不同状态 未使用;等待;准备好运行,等待CPU时间片;正在执行;僵尸进程</span></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">procstate</span> state; <span class="comment">// Process state</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> *parent;  <span class="comment">// Parent process</span></span><br><span class="line">    <span class="type">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">    <span class="type">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe; <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">context</span> context;      <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>user&#x2F;proc.c</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memlayout.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cpu</span> cpus[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> proc[NPROC];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> *initproc;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nextpid = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">spinlock</span> pid_lock; <span class="comment">// 自旋锁（是互斥锁），用于保护进程id的分配</span></span><br><span class="line"><span class="comment">// 保证pid的唯一性，也防止两个进程回收同一个pid，也防止竞争条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">forkret</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">wakeup1</span><span class="params">(<span class="keyword">struct</span> proc *chan)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> trampoline[]; <span class="comment">// trampoline.S</span></span><br></pre></td></tr></table></figure>

<p>procinit()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the proc table at boot time. 在启动时初始化进程表</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">procinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">initlock</span>(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);<span class="comment">//初始化pid_lock这个锁,并且起名便于调试</span></span><br><span class="line">    <span class="comment">// struct proc proc[NPROC];</span></span><br><span class="line">    <span class="comment">// p作为一个指针指向proc数组中的所有进程,从而初始化所有进程</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">initlock</span>(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate a page for the process&#x27;s kernel stack.</span></span><br><span class="line">      <span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line">      <span class="comment">// guard page.</span></span><br><span class="line">      <span class="type">char</span> *pa = <span class="built_in">kalloc</span>();</span><br><span class="line">      <span class="keyword">if</span>(pa == <span class="number">0</span>) <span class="comment">//分配内存页失败</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">      uint64 va = <span class="built_in">KSTACK</span>((<span class="type">int</span>) (p - proc)); <span class="comment">// 计算第k个进程栈的虚拟地址</span></span><br><span class="line">      <span class="comment">// p-proc就是两者的地址差</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">        // each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="comment">        #define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br><span class="line"><span class="comment">		TRAMPOLINE - ((p)+1) * 2 * PGSIZE</span></span><br><span class="line"><span class="comment">        ((p)+1) * 2 * PGSIZE 计算的是从trampoline地址向下偏移的距离</span></span><br><span class="line"><span class="comment">        2 * PGSIZE 表示每个内核栈前后各有一个无效的保护页。</span></span><br><span class="line"><span class="comment">        TRAMPOLINE - ((p)+1) * 2 * PGSIZE 计算的是第(p)个进程的内核栈地址        </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="built_in">kvmmap</span>(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);<span class="comment">//读和写权限</span></span><br><span class="line">      p-&gt;kstack = va;<span class="comment">//给所有进程分配进程栈</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">kvminithart</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initlock()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">initlock</span><span class="params">(<span class="keyword">struct</span> spinlock *lk, <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  lk-&gt;name = name;<span class="comment">// 给锁赋予名字</span></span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>;</span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;<span class="comment">// 暂时没有cpu在占用这个锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kalloc()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct run &#123; </span></span><br><span class="line"><span class="comment">      struct run *next;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">    其实就是一个链表,不过没有数据域,每个节点代表一个可用的内存页</span></span><br><span class="line"><span class="comment">    为什么不需要数据域呢,因为只需要通过run结构体来管理和链接这些内存页</span></span><br><span class="line"><span class="comment">    每个内存页的前几个字节用于存储run结构体，其余部分用于存储实际的数据</span></span><br><span class="line"><span class="comment">    内存页的实际数据存储在run结构体之后的部分,可以认为是隐式的数据域</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock); <span class="comment">// 获取kmem的自旋锁</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    struct &#123;</span></span><br><span class="line"><span class="comment">      struct spinlock lock; // 保证同一时间内只有一个线程可以对自由列表进行访问</span></span><br><span class="line"><span class="comment">      struct run *freelist; // 自由列表的头部,自由列表就是内核空间中还可以被分配的内存页</span></span><br><span class="line"><span class="comment">    &#125; kmem; // kernel memory</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  r = kmem.freelist; 头指针</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next; <span class="comment">// 移除第一个节点,将自由列表中的未分配内存页进行分配</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock); <span class="comment">// 释放锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    <span class="comment">// 如果 r 不为空，将分配的内存页填充为垃圾数据(初始化)</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r; <span class="comment">// 返回指向分配的内存页的指针,为0就是分配失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">push_off</span>(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">holding</span>(lk)) <span class="comment">// 查看是否自身已经持有锁</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">        // Interrupts must be off.</span></span><br><span class="line"><span class="comment">        int</span></span><br><span class="line"><span class="comment">        holding(struct spinlock *lk)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          int r;</span></span><br><span class="line"><span class="comment">          r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span></span><br><span class="line"><span class="comment">          return r;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1 要设置的值</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked 锁的变量状态的地址</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果锁已经被其他 CPU 持有（lk-&gt;locked 为 1），则返回 1，表示获取锁失败，继续自旋</span></span><br><span class="line"><span class="comment">	如果锁未被持有（即 lk-&gt;locked 为 0），则设置 lk-&gt;locked 为 1，表示获取锁成功，退出循环</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line">  <span class="comment">//用于插入完整内存屏障指令，防止 CPU 乱序执行指令</span></span><br><span class="line">  <span class="comment">//这个函数没有参数，只是作为一个内存屏障指令的占位符存在，可以防止编译器优化代码，同时保证 CPU 按照指定的顺序执行指令</span></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = <span class="built_in">mycpu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>release()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holding</span>(lk))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvmmap函数()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table. 向内核页表添加一个映射</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging. 不刷新TLB或启动分页</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@param</span></span><br><span class="line"><span class="comment">	kernel_pagetable: 内核页表</span></span><br><span class="line"><span class="comment">	va: 虚拟地址</span></span><br><span class="line"><span class="comment">	sz: 映射区域的大小</span></span><br><span class="line"><span class="comment">	pa: 物理地址</span></span><br><span class="line"><span class="comment">	perm: 访问权限</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvmmap</span><span class="params">(uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mappages</span>(kernel_pagetable, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mappages()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  a = <span class="built_in">PGROUNDDOWN</span>(va); <span class="comment">// 向下对齐到页边界</span></span><br><span class="line">  last = <span class="built_in">PGROUNDDOWN</span>(va + size - <span class="number">1</span>); <span class="comment">// 将最后一个字节的地址向上对齐到页边界</span></span><br><span class="line">    <span class="comment">// 因为有可能size比较大,需要横跨多个页表</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123; <span class="comment">//循环映射,直到映射完全</span></span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)<span class="comment">//创建或者查找指向虚拟地址a的页表项,查找到的一定是有效的</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)<span class="comment">//如果页表项已经存在并且有效</span></span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;remap&quot;</span>);</span><br><span class="line">    *pte = <span class="built_in">PA2PTE</span>(pa) | perm | PTE_V; <span class="comment">// 物理地址转变为页表项并且设置vaild bit和权限</span></span><br><span class="line">    <span class="keyword">if</span>(a == last)<span class="comment">//到了最后一个页</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;<span class="comment">//虚拟地址移动到下一个页表</span></span><br><span class="line">    pa += PGSIZE;<span class="comment">//物理地址移动到下一个页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kvminithart()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch h/w page table register to the kernel&#x27;s page table,</span></span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="comment">// 切换硬件页表寄存器到内核页表,并且启动分页</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kvminithart</span><span class="params">()</span><span class="comment">//Kernel Virtual Memory Initialize Hart(Hardware Thread)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//初始化内核虚拟内存的硬件线程</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">w_satp</span>(<span class="built_in">MAKE_SATP</span>(kernel_pagetable));<span class="comment">// 切换硬件页表寄存器到内核的页表</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // supervisor address translation and protection;</span></span><br><span class="line"><span class="comment">    // holds the address of the page table.</span></span><br><span class="line"><span class="comment">    // 监督地址翻译和保护,储存页表的地址</span></span><br><span class="line"><span class="comment">    static inline void </span></span><br><span class="line"><span class="comment">    w_satp(uint64 x)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      asm volatile(&quot;csrw satp, %0&quot; : : &quot;r&quot; (x));// -&gt;汇编代码</span></span><br><span class="line"><span class="comment">      //asm关键字用于在CPP中直接嵌入汇编代码</span></span><br><span class="line"><span class="comment">      //csrw是控制/状态寄存器写指令，satp是目标寄存器，%0是占位符,CSR(控制及状态寄存器)</span></span><br><span class="line"><span class="comment">      //satp 寄存器用于存储当前使用的页表的基址和其他相关信息</span></span><br><span class="line"><span class="comment">      //volatile代表告诉编译器不要优化掉这条指令</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="built_in">sfence_vma</span>();<span class="comment">//刷新TLB(translation lookaside buffer)</span></span><br><span class="line">    <span class="comment">//TLB在计组中有提到过,用于加速虚拟地址到物理地址的转换,在MMU内部保存最近访问的页对应表项的小表</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这里啰嗦一点计组的内容，在进行地址转换的时候，虚拟地址的除了offset域的高地址位相当于页表中的页表号</span></span><br><span class="line"><span class="comment">    页表的结构是 控制位|存储器中的页帧</span></span><br><span class="line"><span class="comment">    页表号代表储存在页表的第几个位置，页表在这里就像一个数组，页表号是下标，储存的值就是实际的页帧</span></span><br><span class="line"><span class="comment">    虚页一共有多少页，页表中就有多少个pte</span></span><br><span class="line"><span class="comment">    由于我们知道，不同的进程都有自己不同的页表来实现隔离，所以在查找的时候</span></span><br><span class="line"><span class="comment">    首先要知道当前进程页表的起始地址（存储在页表基址存储器中），加上虚拟页号就是该虚拟页号</span></span><br><span class="line"><span class="comment">    在页表中对应的实际地址（类似数组中首地址加偏移量就是该项的地址），对应就可以在该地址读取出</span></span><br><span class="line"><span class="comment">    对应的物理页帧了</span></span><br><span class="line"><span class="comment">    但在TLB中是不同的</span></span><br><span class="line"><span class="comment">    TLB的结构是 虚拟页号|控制位|存储器中的页帧</span></span><br><span class="line"><span class="comment">    所以在TLB中寻址的时候是不可以直接对应到TLB的某个位置直接读取对应的页帧的</span></span><br><span class="line"><span class="comment">    需要顺序进行搜索然后比对虚拟页号，直到找到对应的页号并且查看控制位是否有效决定是</span></span><br><span class="line"><span class="comment">    miss-&gt;从页表中查找并更新刷新TLB</span></span><br><span class="line"><span class="comment">    hit-&gt;直接获取物理页帧地址</span></span><br><span class="line"><span class="comment">    所以TLB实际上相当于使用了全相联映射技术,需要一个个比对直到查找到对应的信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//比如在多级的页表映射中进行逐级查找(前面的代码中有体现)是非常麻烦的</span></span><br><span class="line">    <span class="comment">//所以TLB缓存虚拟地址和其映射的物理地址,根据虚拟地址查找cache</span></span><br><span class="line">    <span class="comment">//TLB其实不需要存储虚拟地址和物理地址的低12位(因为低12位都一样,是页内偏移量)即不需要offset域</span></span><br><span class="line">    <span class="comment">//当切换到新的页表时，需要刷新TLB以确保新的映射生效</span></span><br><span class="line">    <span class="comment">//在修改页表条目后，也要刷新TLB以确保后续的内存访问使用最新的映射</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // flush the TLB.</span></span><br><span class="line"><span class="comment">    static inline void</span></span><br><span class="line"><span class="comment">    sfence_vma()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      // the zero, zero means flush all TLB entries.</span></span><br><span class="line"><span class="comment">      asm volatile(&quot;sfence.vma zero, zero&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cpuid()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Must be called with interrupts disabled,</span></span><br><span class="line"><span class="comment">// to prevent race with process being moved</span></span><br><span class="line"><span class="comment">// to a different CPU. 必须禁用中断,防止进程被调度到另一个cpu上</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">cpuid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> id = <span class="built_in">r_tp</span>();<span class="comment">//读取tp寄存器的值</span></span><br><span class="line">    <span class="comment">// tp寄存器用于存储线程指针,指向当前线程的上下文信息(context)</span></span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于后面的函数太多了,所以比较简单的函数就不再作说明</p>
<p>allocpid（）函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">allocpid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;pid_lock);<span class="comment">//必须要上锁,</span></span><br><span class="line">  pid = nextpid;</span><br><span class="line">  nextpid = nextpid + <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">release</span>(&amp;pid_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>allocproc()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/ Look in the process table <span class="keyword">for</span> an UNUSED proc.</span><br><span class="line"><span class="comment">// If found, initialize state required to run in the kernel,</span></span><br><span class="line"><span class="comment">// and return with p-&gt;lock held.</span></span><br><span class="line"><span class="comment">// If there are no free procs, or a memory allocation fails, return 0.</span></span><br><span class="line"><span class="comment">//用于在进程表中查找一个未使用的进程结构，并初始化该进程所需的状态，以便其能够在内核中运行</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">proc</span>*</span><br><span class="line"><span class="built_in">allocproc</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">	<span class="comment">// 在进程表中查找一个未使用的进程结构</span></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);<span class="comment">//获取进程锁</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == UNUSED) &#123;<span class="comment">//找到未使用的进程</span></span><br><span class="line">      <span class="keyword">goto</span> found;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);<span class="comment">//释放</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">  p-&gt;pid = <span class="built_in">allocpid</span>();<span class="comment">//分配新的pid</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// kalloc()只是分配一个可以使用的kernel中的物理页,返回的是(void*)</span></span><br><span class="line">      <span class="comment">// 所以用于作为页还是陷阱帧都是可以的</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = <span class="built_in">proc_pagetable</span>(p);<span class="comment">//这个函数在后面有详细的分析,用于创建一个新的用户列表</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(p);<span class="comment">// 创建页表失败，释放进程资源</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line">  <span class="comment">// which returns to user space.</span></span><br><span class="line">  <span class="comment">// 设置新的上下文，从forkret开始执行，返回到用户空间</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="built_in">sizeof</span>(p-&gt;context));<span class="comment">// 将上下文结构清零</span></span><br><span class="line">  p-&gt;context.ra = (uint64)forkret;<span class="comment">// 设置返回地址为forkret,也就是内核返回到用户空间的入口点</span></span><br><span class="line">  <span class="comment">// forkret 是一个特殊的函数，它在新创建的子进程第一次被调度器调度时调用</span></span><br><span class="line">  <span class="comment">// forkret 负责释放进程锁、初始化文件系统（如果需要）以及最终返回用户态</span></span><br><span class="line">  <span class="comment">// 确保新进程在第一次被调度时能够正确地初始化并返回用户态</span></span><br><span class="line">  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<span class="comment">//设置堆栈指针为内核栈的顶部</span></span><br><span class="line">    <span class="comment">// 时刻需要记住内存空间的堆栈模型,栈一定是从高地址向低地址进行增长的</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freeproc()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// free a proc structure and the data hanging from it,</span></span><br><span class="line"><span class="comment">// including user pages.</span></span><br><span class="line"><span class="comment">// p-&gt;lock must be held.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)p-&gt;trapframe);<span class="comment">//释放陷阱帧中的所有内容,将其转换为空闲的可用的页面</span></span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    <span class="built_in">proc_freepagetable</span>(p-&gt;pagetable, p-&gt;sz);<span class="comment">//释放进程页表中的内容</span></span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>; <span class="comment">// 清除进程 ID</span></span><br><span class="line">  p-&gt;parent = <span class="number">0</span>; <span class="comment">// 清除父进程指针</span></span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 清除进程名称</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>; <span class="comment">// 清除通道指针</span></span><br><span class="line">  p-&gt;killed = <span class="number">0</span>; <span class="comment">// 清除杀死标志</span></span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>; <span class="comment">// 清除扩展状态</span></span><br><span class="line">  p-&gt;state = UNUSED; <span class="comment">// 设置进程状态为未使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kfree()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/ Free the page of physical memory pointed at by v,</span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="comment">// 一般用于释放由kalloc分配的物理内存页面</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line">  <span class="comment">// 检查传入的地址是否合法</span></span><br><span class="line">  <span class="comment">// 首先地址必须是页对齐的,地址必须是PGSIZE的倍数</span></span><br><span class="line">  <span class="comment">// 地址必须在end和PHYSTOP之间，其中end是内核结束地址，PHYSTOP是物理内存的上限</span></span><br><span class="line">    <span class="comment">// the kernel expects there to be RAM</span></span><br><span class="line">	<span class="comment">// for use by the kernel and user pages</span></span><br><span class="line">	<span class="comment">// from physical address 0x80000000 to PHYSTOP.</span></span><br><span class="line">	<span class="comment">// #define KERNBASE 0x80000000L</span></span><br><span class="line">    <span class="comment">// 硬件设备通常会被映射到较低的地址空间范围,所以在这里内核加载到0x80000000处</span></span><br><span class="line">	<span class="comment">// #define PHYSTOP (KERNBASE + 128*1024*1024) // 内存为128MB</span></span><br><span class="line">    <span class="comment">// KERNBASE到PHYSTOP是内核和用户页面的物理地址范围</span></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="comment">//将释放的页面填充为全1，在后续使用时更容易发现悬空引用（即对已释放内存的非法访问）  </span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;<span class="comment">//将释放的页面地址转换为run类型</span></span><br><span class="line">    <span class="comment">// 前文有提到过每个内存页的前几个字节用于存储run结构体，其余部分用于存储实际的数据</span></span><br><span class="line">    <span class="comment">// 所以内存页的开始地址可以认为指向一个页,也可以认为指向一个run结构体,其地址都是相同的</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;<span class="comment">//将释放后变为空闲的页面链接到空闲内存页的链表头部</span></span><br><span class="line">  kmem.freelist = r;<span class="comment">//更改头指针</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freepagetable()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="comment">// 释放一个进程的页表,并且同时释放其指向的物理内存</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">uvmunmap</span>(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//uvm应该是user virtual memory</span></span><br><span class="line">    <span class="comment">// 解除pagetable到TRAMPOLINE地址开始,一共1页的映射关系(也就是去除指向其的表项)</span></span><br><span class="line">    <span class="comment">// 去除表项可以通过walk函数查找到,walk()返回虚拟地址对应的pte并且可以选择是否在未找到时创建</span></span><br><span class="line">    <span class="comment">// 最后一个参数表示是否需要将指向的物理内存也释放</span></span><br><span class="line">    <span class="comment">// TRAMPOLINE是一个特殊的虚拟地址，用于在用户空间和内核空间之间进行切换</span></span><br><span class="line">    <span class="comment">// TRAMPOLINE页被映射到虚拟地址空间的顶端</span></span><br><span class="line">    <span class="comment">// 1表示解除映射的页数,0表示不需要释放物理页面</span></span><br><span class="line">  <span class="built_in">uvmunmap</span>(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//释放陷阱帧</span></span><br><span class="line">    <span class="comment">// uvmunmap的逻辑很简单,就是根据最后一个参数决定使用kfree对于指向的物理内存进行释放</span></span><br><span class="line">    <span class="comment">// 然后将页表项置为0</span></span><br><span class="line">  <span class="built_in">uvmfree</span>(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uvmfree()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free user memory pages,</span></span><br><span class="line"><span class="comment">// then free page-table pages.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">uvmfree</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(sz &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">uvmunmap</span>(pagetable, <span class="number">0</span>, <span class="built_in">PGROUNDUP</span>(sz)/PGSIZE, <span class="number">1</span>); <span class="comment">// 释放用户内存页面</span></span><br><span class="line">  <span class="built_in">freewalk</span>(pagetable);<span class="comment">// 释放页表页面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>freewalk()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];<span class="comment">//获取第i个页表项</span></span><br><span class="line">    <span class="keyword">if</span>((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="number">0</span>)&#123;<span class="comment">//是否是中间节点且有效</span></span><br><span class="line">        <span class="comment">//PTE_R指示这一页物理帧是否能被读。</span></span><br><span class="line">		<span class="comment">//PTE_W指示这一页物理帧是否能被写。</span></span><br><span class="line">		<span class="comment">//PTE_X指示这一页物理帧是否能被CPU看待并转换成指令来执行</span></span><br><span class="line">      <span class="comment">//(pte &amp; (PTE_R|PTE_W|PTE_X)) == 0说明这个 PTE 指向一个更低级别的页表</span></span><br><span class="line">      <span class="comment">//通常中间节点页表项的PTE_R、PTE_W和PTE_X位都为 0</span></span><br><span class="line">      uint64 child = <span class="built_in">PTE2PA</span>(pte);<span class="comment">// 将pte转换为物理地址</span></span><br><span class="line">      <span class="built_in">freewalk</span>((<span class="type">pagetable_t</span>)child);<span class="comment">// 递归释放子页表</span></span><br><span class="line">      pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pte &amp; PTE_V)&#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;freewalk: leaf&quot;</span>);<span class="comment">//PTE是有效的但不是指向子页表</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//如果是一个叶子节点就可以直接在此处释放,所以在上面不做处理</span></span><br><span class="line">  <span class="built_in">kfree</span>((<span class="type">void</span>*)pagetable);<span class="comment">// 释放当前页表所占有的物理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initcode[]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a user program that calls exec(&quot;/init&quot;)</span></span><br><span class="line"><span class="comment">// od -t xC initcode</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们总是需要有一个用户进程在运行，这样才能实现与操作系统的交互，</span></span><br><span class="line"><span class="comment">所以这里需要一个小程序来初始化第一个用户进程。</span></span><br><span class="line"><span class="comment">这个小程序定义在initcode中,通过exec调用init程序</span></span><br><span class="line"><span class="comment">init会为用户空间设置好一些东西，比如配置好console，调用fork，并在fork出的子进程中执行shell</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">uchar initcode[] = &#123;</span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x45</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x97</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x93</span>, <span class="number">0x85</span>, <span class="number">0x35</span>, <span class="number">0x02</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x93</span>, <span class="number">0x08</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x73</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0xef</span>, <span class="number">0xf0</span>, <span class="number">0x9f</span>, <span class="number">0xff</span>, <span class="number">0x2f</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x69</span>,</span><br><span class="line">  <span class="number">0x74</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>userinit()函数，这个很重要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up first user process.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">userinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  p = <span class="built_in">allocproc</span>();<span class="comment">// 分配进程</span></span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="built_in">uvminit</span>(p-&gt;pagetable, initcode, <span class="built_in">sizeof</span>(initcode));<span class="comment">//initcode用于执行&quot;/init&quot;程序,如上</span></span><br><span class="line">  p-&gt;sz = PGSIZE;<span class="comment">// 将进程的大小设置为一个页</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter 用户程序入口为0</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer 指向页面顶部</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="built_in">sizeof</span>(p-&gt;name));<span class="comment">// 为进程命名</span></span><br><span class="line">  p-&gt;cwd = <span class="built_in">namei</span>(<span class="string">&quot;/&quot;</span>);<span class="comment">// 表示进程的当前工作目录是根目录(cwd= current work directory)</span></span><br><span class="line">    <span class="comment">// namei函数查找并返回根目录的 inode 结构</span></span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>uvminit()函数 user virtual memory init</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Load the user initcode into address 0 of pagetable,</span></span><br><span class="line"><span class="comment">// for the very first process.</span></span><br><span class="line"><span class="comment">// sz must be less than a page.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">uvminit</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uchar *src, uint sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(sz &gt;= PGSIZE)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;inituvm: more than a page&quot;</span>);</span><br><span class="line">  mem = <span class="built_in">kalloc</span>();<span class="comment">// 分配一个页面大小的内存块</span></span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="built_in">mappages</span>(pagetable, <span class="number">0</span>, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);</span><br><span class="line">    <span class="comment">// 将内存块映射到进程的页表中,设置一些权限标志</span></span><br><span class="line">  <span class="built_in">memmove</span>(mem, src, sz);<span class="comment">//将initcode复制到分配的内存块中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fork()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i, pid;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *np;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;<span class="comment">//将父进程的用户内存复制到子进程的页表中</span></span><br><span class="line">    <span class="built_in">freeproc</span>(np);<span class="comment">// 如果复制失败，释放新进程</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);<span class="comment">// 释放锁,因为在allocproc()函数中会自动加锁,所以在这里是隐式的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">  np-&gt;parent = p;<span class="comment">// 设置子进程的父进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers. 复制陷阱帧</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child. a0为返回值寄存器,保证子程序的fork返回值为0</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)<span class="comment">//最多16个文件描述符</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = <span class="built_in">filedup</span>(p-&gt;ofile[i]);</span><br><span class="line">    <span class="comment">// 遍历父进程的文件描述符数组，如果文件描述符有效，则调用 filedup 函数增加引用计数</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    // Increment ref count for file f.</span></span><br><span class="line"><span class="comment">        struct &#123;</span></span><br><span class="line"><span class="comment">          struct spinlock lock;</span></span><br><span class="line"><span class="comment">          struct file file[NFILE];</span></span><br><span class="line"><span class="comment">        &#125; ftable;</span></span><br><span class="line"><span class="comment">        struct file*</span></span><br><span class="line"><span class="comment">        filedup(struct file *f)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          acquire(&amp;ftable.lock);</span></span><br><span class="line"><span class="comment">          if(f-&gt;ref &lt; 1)// 说明文件描述符无效</span></span><br><span class="line"><span class="comment">            panic(&quot;filedup&quot;);</span></span><br><span class="line"><span class="comment">          f-&gt;ref++;</span></span><br><span class="line"><span class="comment">          release(&amp;ftable.lock);</span></span><br><span class="line"><span class="comment">          return f;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 并将文件描述符复制到子进程的文件描述符数组中</span></span><br><span class="line">  np-&gt;cwd = <span class="built_in">idup</span>(p-&gt;cwd);<span class="comment">// 复制父进程的当前工作目录</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(np-&gt;name, p-&gt;name, <span class="built_in">sizeof</span>(p-&gt;name));<span class="comment">// 复制进程名</span></span><br><span class="line"></span><br><span class="line">  pid = np-&gt;pid;<span class="comment">//获取子进程的进程标识符,pid用全局变量nextpid进行维护</span></span><br><span class="line"></span><br><span class="line">  np-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pid;<span class="comment">// 返回子进程的pid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reparent()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass p&#x27;s abandoned children to init.</span></span><br><span class="line"><span class="comment">// Caller must hold p-&gt;lock.</span></span><br><span class="line"><span class="comment">// 用于把所有孤儿进程托管到init进程下,不会的导致其他问题但是会占用进程表导致进程表满</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">reparent</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *pp;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(pp = proc; pp &lt; &amp;proc[NPROC]; pp++)&#123;</span><br><span class="line">    <span class="comment">// 检查当前进程 pp 的父进程是否为 p。</span></span><br><span class="line">    <span class="comment">// 这里没有对 pp-&gt;lock 进行加锁，因为加锁可能会导致死锁。</span></span><br><span class="line">    <span class="comment">// 具体来说，如果 pp 或其子进程也在 exit 函数中并且即将尝试锁定 p，则会导致死锁</span></span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;parent == p)&#123;</span><br><span class="line">      <span class="comment">// pp-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">      <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">      <span class="built_in">acquire</span>(&amp;pp-&gt;lock);</span><br><span class="line">      pp-&gt;parent = initproc;</span><br><span class="line">      <span class="comment">// we should wake up init here, but that would require</span></span><br><span class="line">      <span class="comment">// initproc-&gt;lock, which would be a deadlock, since we hold</span></span><br><span class="line">      <span class="comment">// the lock on one of init&#x27;s children (pp). this is why</span></span><br><span class="line">      <span class="comment">// exit() always wakes init (before acquiring any locks).</span></span><br><span class="line">      <span class="comment">// 比如说如果initproc需要获取pp-&gt;lock那么就会出问题,因为initproc会等待 pp-&gt;lock</span></span><br><span class="line">      <span class="comment">// 而我们又在等待initproc-&gt;lock</span></span><br><span class="line">      <span class="comment">// 因此，唤醒 initproc 的操作通常在exit函数中进行，且在获取任何锁之前</span></span><br><span class="line">      <span class="built_in">release</span>(&amp;pp-&gt;lock);</span><br><span class="line">        </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      不在检查pp-&gt;parent时加锁，以避免与pp或其子进程在exit函数中尝试锁定p时产生死锁。</span></span><br><span class="line"><span class="comment">      在修改pp-&gt;parent时加锁，确保修改操作的原子性和一致性。</span></span><br><span class="line"><span class="comment">      唤醒initproc的操作在exit函数中进行，且在获取任何锁之前，以避免死锁</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exit()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exit the current process.  Does not return.退出当前进程但是不返回</span></span><br><span class="line"><span class="comment">// An exited process remains in the zombie state一个退出了的进程在僵尸状态</span></span><br><span class="line"><span class="comment">// until its parent calls wait().直到其父亲调用了wait</span></span><br><span class="line"><span class="comment">/* @param </span></span><br><span class="line"><span class="comment">	status:进程退出时的状态值，即在使用时给它一个无符号的整型数，该数将会作为进程的退出状态</span></span><br><span class="line"><span class="comment">	并且要在0-255范围内，否则将自动默认为未定义退出状态值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == initproc)<span class="comment">// initproc不应该被退出</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;init exiting&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Close all open files.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">file</span> *f = p-&gt;ofile[fd];</span><br><span class="line">      <span class="built_in">fileclose</span>(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">begin_op</span>();<span class="comment">// 首先需要保证文件系统的操作是安全的</span></span><br><span class="line">  <span class="built_in">iput</span>(p-&gt;cwd);<span class="comment">// 释放当前工作目录(减少一次引用,如果减少到0那么inode会被回收)</span></span><br><span class="line">  <span class="built_in">end_op</span>();</span><br><span class="line">  p-&gt;cwd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we might re-parent a child to init. we can&#x27;t be precise about</span></span><br><span class="line">  <span class="comment">// waking up init, since we can&#x27;t acquire its lock once we&#x27;ve</span></span><br><span class="line">  <span class="comment">// acquired any other proc lock. so wake up init whether that&#x27;s</span></span><br><span class="line">  <span class="comment">// necessary or not. init may miss this wakeup, but that seems</span></span><br><span class="line">  <span class="comment">// harmless.</span></span><br><span class="line">  <span class="comment">// 获取initproc的锁，唤醒initproc，以便它可以接收孤儿进程</span></span><br><span class="line">  <span class="comment">// 由于并发控制的需要，一旦获取了某个进程的锁，就不能再获取其他进程的锁，以避免死锁</span></span><br><span class="line">  <span class="comment">// 因此，在已经获取了当前进程或其他进程的锁的情况下，无法精确地获取 init 进程的锁</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;initproc-&gt;lock);</span><br><span class="line">  <span class="built_in">wakeup1</span>(initproc);<span class="comment">// wakeup1专门用于唤醒slepping in wait()的进程p,使用前必须获取p的lock</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;initproc-&gt;lock);</span><br><span class="line">  <span class="comment">/* initproc的主要职责是初始化用户态环境，并启动其他必要的系统进程和服务</span></span><br><span class="line"><span class="comment">   因此，initproc会有很多子进程，这些子进程通常包括系统服务、守护进程和其他用户态程序</span></span><br><span class="line"><span class="comment">   initproc在以下情况下可能会进入睡眠状态:</span></span><br><span class="line"><span class="comment">	1.等待子进程退出: 在调用wait系统调用时。</span></span><br><span class="line"><span class="comment">	2.等待系统事件: 在等待特定事件发生时。</span></span><br><span class="line"><span class="comment">	3.空闲状态: 在没有任务需要处理时。</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 获取 p-&gt;parent 的副本，以确保我们解锁的是同一个父进程。</span></span><br><span class="line">  <span class="comment">// 以防我们的父进程在我们等待父进程锁时将我们交给 init。</span></span><br><span class="line">  <span class="comment">// 这样做可能会与一个正在退出的父进程产生竞争条件，</span></span><br><span class="line"> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	竞争条件: 在获取父进程锁的过程中，父进程可能会退出</span></span><br><span class="line"><span class="comment"> 	如果父进程在当前进程等待锁时退出，可能会导致当前进程的父进程引用发生变化</span></span><br><span class="line"><span class="comment"> 	当前进程 p 正在等待获取父进程 original_parent 的锁</span></span><br><span class="line"><span class="comment">	在等待期间，父进程 original_parent 退出，并将当前进程 p 重新分配给 initproc</span></span><br><span class="line"><span class="comment">	当前进程 p 终于获取到了锁，但此时父进程已经不再是原来的 original_parent，而是 initproc</span></span><br><span class="line"><span class="comment"> 	*/</span></span><br><span class="line">  <span class="comment">// 但结果只会是一个无害的虚假唤醒，唤醒一个已经退出或错误的进程；</span></span><br><span class="line">  <span class="comment">// 进程结构体永远不会被重新分配为其他用途。</span></span><br><span class="line">  <span class="comment">// 为了确保在后续操作中锁定的是正确的父进程，即使父进程在这段时间内已经被重新分配给initproc</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *original_parent = p-&gt;parent;</span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we need the parent&#x27;s lock in order to wake it up from wait().</span></span><br><span class="line">  <span class="comment">// the parent-then-child rule says we have to lock it first.</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;original_parent-&gt;lock); <span class="comment">// 获取父进程的锁，以便可以安全地唤醒父进程</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Give any children to init.</span></span><br><span class="line">  <span class="built_in">reparent</span>(p);<span class="comment">// 将p的子进程重新分配给initproc</span></span><br><span class="line">  <span class="comment">// 因为p此刻马上要退出了.所以其还没有退出的子进程就会变成孤儿进程,需要进行托管</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parent might be sleeping in wait().</span></span><br><span class="line">  <span class="built_in">wakeup1</span>(original_parent);<span class="comment">// 唤醒父进程，使其从wait函数中返回</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置当前进程的退出状态和状态为僵尸状态</span></span><br><span class="line">  p-&gt;xstate = status;</span><br><span class="line">  p-&gt;state = ZOMBIE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;original_parent-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Jump into the scheduler, never to return.</span></span><br><span class="line">  <span class="built_in">sched</span>();</span><br><span class="line">    <span class="comment">// 跳转到调度器，让出CPU。理论上，调度器会安排其他进程运行</span></span><br><span class="line">    <span class="comment">// 而当前进程会保持在僵尸状态，直到其父进程调用wait将其清理。</span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;zombie exit&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fileclose()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close file f.  (Decrement ref count, close when reaches 0.)</span></span><br><span class="line"><span class="comment">// 关闭文件f,减少文件的引用计数直到到达0的时候才真正关闭</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">file</span> &#123;</span><br><span class="line">  <span class="keyword">enum</span> &#123; FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;</span><br><span class="line">    <span class="comment">// 文件描述符未使用,管道,文件或目录,设备</span></span><br><span class="line">  <span class="type">int</span> ref; <span class="comment">// reference count</span></span><br><span class="line">  <span class="type">char</span> readable;<span class="comment">// 1/0</span></span><br><span class="line">  <span class="type">char</span> writable;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">pipe</span> *pipe; <span class="comment">// FD_PIPE 指向管道的指针</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">inode</span> *ip;  <span class="comment">// FD_INODE and FD_DEVICE 指向inode/设备的指针</span></span><br><span class="line">  uint off;          <span class="comment">// FD_INODE 文件的当前偏移量</span></span><br><span class="line">  <span class="type">short</span> major;       <span class="comment">// FD_DEVICE 设备的主设备号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pipe</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="type">char</span> data[PIPESIZE];</span><br><span class="line">  uint nread;     <span class="comment">// number of bytes read</span></span><br><span class="line">  uint nwrite;    <span class="comment">// number of bytes written</span></span><br><span class="line">  <span class="type">int</span> readopen;   <span class="comment">// read fd is still open</span></span><br><span class="line">  <span class="type">int</span> writeopen;  <span class="comment">// write fd is still open</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">fileclose</span><span class="params">(<span class="keyword">struct</span> file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> ff;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;ftable.lock);<span class="comment">//获取锁保证操作的一致性</span></span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>) <span class="comment">// 已经关闭</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;fileclose&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(--f-&gt;ref &gt; <span class="number">0</span>)&#123; <span class="comment">// 说明还有其他进程在引用</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;ftable.lock);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 否则说明没有进程在引用该文件,进行关闭操作</span></span><br><span class="line">  ff = *f;</span><br><span class="line">  f-&gt;ref = <span class="number">0</span>;</span><br><span class="line">  f-&gt;type = FD_NONE;<span class="comment">// 表示文件已经关闭</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;ftable.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ff.type == FD_PIPE)&#123;</span><br><span class="line">    <span class="built_in">pipeclose</span>(ff.pipe, ff.writable);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ff.type == FD_INODE || ff.type == FD_DEVICE)&#123;</span><br><span class="line">    <span class="built_in">begin_op</span>();</span><br><span class="line">    <span class="built_in">iput</span>(ff.ip);<span class="comment">// 调用 iput 函数释放文件的 inode 引用</span></span><br><span class="line">    <span class="built_in">end_op</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pipeclose()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pipeclose</span><span class="params">(<span class="keyword">struct</span> pipe *pi, <span class="type">int</span> writable)</span><span class="comment">// wirtable用于决定关闭读端还是写端</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;pi-&gt;lock);</span><br><span class="line">  <span class="keyword">if</span>(writable)&#123;</span><br><span class="line">    pi-&gt;writeopen = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(&amp;pi-&gt;nread);</span><br><span class="line">    <span class="comment">//唤醒所有等待读取的进程。这些进程可能会因为写端关闭而结束等待状态</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pi-&gt;readopen = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">wakeup</span>(&amp;pi-&gt;nwrite);</span><br><span class="line">    <span class="comment">//唤醒所有等待写的进程。这些进程可能会因为读端关闭而结束等待状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pi-&gt;readopen == <span class="number">0</span> &amp;&amp; pi-&gt;writeopen == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;pi-&gt;lock);</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">char</span>*)pi);</span><br><span class="line">      <span class="comment">// 如果两端都已经关闭,释放管道的锁，并调用 kfree 函数释放管道占用的内存</span></span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;pi-&gt;lock);<span class="comment">// 否则仅释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wakeup()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="comment">// 唤醒所有在chan上等待的进程,进程必须无锁</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;<span class="comment">// 其等待的通道是否与传入的chan匹配</span></span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>begin_op()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the start of each FS system call.</span></span><br><span class="line"><span class="comment">// 控制对文件系统的并发访问，并确保日志空间不会被耗尽</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">begin_op</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;log.lock);<span class="comment">// 获取日志的锁</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(log.committing)&#123; <span class="comment">// 如果有日志正在提交那么就将当前线程sleep</span></span><br><span class="line">      <span class="built_in">sleep</span>(&amp;log, &amp;log.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(log.lh.n + (log.outstanding<span class="number">+1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit.</span></span><br><span class="line">      <span class="comment">// log.lh.n表示当前已使用的日志空间大小，log.outstanding是当前正在处理但未提交的操作数量	</span></span><br><span class="line">      <span class="comment">// MAXOPBLOCKS定义了一个操作可能需要的最大日志块数，而LOGSIZE则是整个日志空间的大小</span></span><br><span class="line">      <span class="built_in">sleep</span>(&amp;log, &amp;log.lock);<span class="comment">// 日志空间不足</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.outstanding += <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">release</span>(&amp;log.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>end_op()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="comment">// 在所有正在进行的操作完成后触发一次日志提交</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">end_op</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;log.lock);</span><br><span class="line">  log.outstanding -= <span class="number">1</span>; <span class="comment">// 减少正在进行的操作计数</span></span><br><span class="line">  <span class="keyword">if</span>(log.committing) <span class="comment">// 不应该在一个日志提交过程中尝试结束另一个操作</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(log.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    log.committing = <span class="number">1</span>;<span class="comment">// 开始提交</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    <span class="comment">// 如果还有其他操作正在进行，唤醒可能因日志空间不足而等待的线程</span></span><br><span class="line">    <span class="comment">// 因为减少log.outstanding可能会释放足够的日志空间</span></span><br><span class="line">    <span class="built_in">wakeup</span>(&amp;log);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;log.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    <span class="comment">// 这里不持有任何锁，因为commit函数可能需要睡眠，而持有锁时不能睡眠</span></span><br><span class="line">    <span class="built_in">commit</span>();<span class="comment">// 进行日志提交</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;log.lock); <span class="comment">// 在日志提交完成后重新获取锁</span></span><br><span class="line">    log.committing = <span class="number">0</span>; <span class="comment">// 标记日志提交结束</span></span><br><span class="line">    <span class="built_in">wakeup</span>(&amp;log);<span class="comment">// 唤醒可能因等待日志提交结束而阻塞的线程</span></span><br><span class="line">    <span class="built_in">release</span>(&amp;log.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>产生死锁的四个必要条件：</strong></p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>持有锁时不能睡眠-&gt;对应第（2）条规则</p>
<p>“一旦获取了某个进程的锁，就不能再获取其他进程的锁，以避免死锁”主要是为了防止循环等待，例如，进程 A 持有锁 L1 并试图获取锁 L2，而进程 B 持有锁 L2 并试图获取锁 L1，这就形成了一个死锁环，导致死锁</p>
<p><strong>唤醒父进程</strong>: 当一个子进程退出时，需要唤醒其父进程，使父进程从 <code>wait</code> 系统调用中返回。为了确保在唤醒父进程时不会出现竞争条件，需要获取父进程的锁。这确保了在唤醒父进程之前，父进程的状态不会被其他线程修改。</p>
<p><strong>父进程-子进程规则 (Parent-Then-Child Rule)</strong>:</p>
<p><strong>锁的获取顺序</strong>: 在多线程或多进程环境中，为了避免死锁，通常会有一个明确的锁获取顺序。这里的“父进程-子进程规则”是指在处理父进程和子进程的关系时，必须先获取父进程的锁，然后再获取子进程的锁。</p>
<p>原因: 这个规则有助于避免死锁。如果两个进程（或线程）在不同的顺序下获取相同的锁，可能会导致循环等待，进而引发死锁。例如：</p>
<ul>
<li><p>进程 A 持有子进程的锁，试图获取父进程的锁。</p>
</li>
<li><p>进程 B 持有父进程的锁，试图获取子进程的锁。</p>
</li>
<li><p>这种情况下，进程 A 和 B 都会陷入等待状态，形成死锁</p>
</li>
</ul>
<p><strong>wait（</strong>）函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wait for a child process to exit and return its pid.</span></span><br><span class="line"><span class="comment">// Return -1 if this process has no children.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">wait</span><span class="params">(uint64 addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *np;</span><br><span class="line">  <span class="type">int</span> havekids, pid;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hold p-&gt;lock for the whole time to avoid lost</span></span><br><span class="line">  <span class="comment">// wakeups from a child&#x27;s exit().</span></span><br><span class="line">  <span class="comment">// 获取当前进程 p 的锁，确保在整个 wait 函数执行过程中不会丢失来自子进程 exit 的唤醒信号</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">    <span class="comment">// 无限循环不断检查是否有子进程退出</span></span><br><span class="line">    havekids = <span class="number">0</span>;<span class="comment">// 现在无子进程</span></span><br><span class="line">    <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">      <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">      <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">      <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">      <span class="comment">// 根据父子进程规则,必须先获取父进程的锁才能获取子进程的锁,所以在读取过程中不可以加锁</span></span><br><span class="line">      <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">        <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">        <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">        <span class="comment">// 在下一行代码的acquire()和上面的检查之间np的父进程不会变化</span></span><br><span class="line">        <span class="comment">// 因为只有父进程可以对其进行修改,而p就是其父进程</span></span><br><span class="line">        <span class="comment">// 这里应该是用于说明在下面acquire()的锁就是上面检查到的np,其父进程不会改变</span></span><br><span class="line">        <span class="built_in">acquire</span>(&amp;np-&gt;lock);</span><br><span class="line">        havekids = <span class="number">1</span>; <span class="comment">// 表示当前进程有子进程</span></span><br><span class="line">        <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">          <span class="comment">// Found one.</span></span><br><span class="line">          pid = np-&gt;pid;</span><br><span class="line">          <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; <span class="built_in">copyout</span>(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                  <span class="built_in">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果addr不为0，使用copyout将子进程的退出状态复制到用户空间地址addr</span></span><br><span class="line">            <span class="comment">// 如果参数addr的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值</span></span><br><span class="line">            <span class="comment">// 如果 copyout 失败，释放所有锁并返回 -1</span></span><br><span class="line">            <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">            <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 调用freeproc释放子进程的资源</span></span><br><span class="line">          <span class="built_in">freeproc</span>(np);</span><br><span class="line">          <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">          <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">          <span class="keyword">return</span> pid;<span class="comment">// 释放锁,返回子进程的pid</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No point waiting if we don&#x27;t have any children.</span></span><br><span class="line">    <span class="comment">// 当前进程没有子进程，或者当前进程被杀死，释放当前进程的锁并返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(!havekids || p-&gt;killed)&#123;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Wait for a child to exit.</span></span><br><span class="line">    <span class="comment">// 调用sleep使当前进程进入睡眠状态，等待子进程退出</span></span><br><span class="line">    <span class="built_in">sleep</span>(p, &amp;p-&gt;lock);  <span class="comment">//DOC: wait-sleep</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>secheduler()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU process scheduler.</span></span><br><span class="line"><span class="comment">// Each CPU calls scheduler() after setting itself up.</span></span><br><span class="line"><span class="comment">// Scheduler never returns.  It loops, doing:</span></span><br><span class="line"><span class="comment">//  - choose a process to run.</span></span><br><span class="line"><span class="comment">//  - swtch to start running that process.</span></span><br><span class="line"><span class="comment">//  - eventually that process transfers control</span></span><br><span class="line"><span class="comment">//    via swtch back to the scheduler.</span></span><br><span class="line"><span class="comment">// 每个CPU在初始化完成后都会调用这个调度器。调度器的主要任务是在所有进程中选择一个可运行的进程</span></span><br><span class="line"><span class="comment">// 并切换到该进程执行，直到该进程自愿放弃CPU控制权或被中断打断，再回到调度器继续选择下一个可运行的进程</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">scheduler</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>; <span class="comment">// 初始化为0表示现在没有运行任何进程</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123; <span class="comment">// 使用一个无限循环来不断选择和运行进程</span></span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="comment">// 启用中断，确保设备可以中断当前进程，避免死锁</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>; <span class="comment">// 表示是否找到了可运行的进程</span></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;p-&gt;lock);<span class="comment">// 先获取锁防止别的进程进行修改</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;<span class="comment">// 将当前CPU的当前进程指针c-&gt;proc设置为该进程p</span></span><br><span class="line">        <span class="built_in">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);<span class="comment">// 使用swtch函数切换到该进程的上下文，开始执行该进程</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          CPU 上下文切换就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来</span></span><br><span class="line"><span class="comment">          然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务</span></span><br><span class="line"><span class="comment">		  而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来</span></span><br><span class="line"><span class="comment">		  这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行</span></span><br><span class="line"><span class="comment">		  切换上下文 == 运行新的程序</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="comment">// 在xv6中是由一个汇编语言程序写成的</span></span><br><span class="line">        <span class="comment">// void swtch(struct context *old, struct context *new)</span></span><br><span class="line">        <span class="comment">// 后面的是要切换去运行的进程,前面的是现在正在运行的进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        <span class="comment">// 当进程执行完毕后，返回到调度器，将 c-&gt;proc 设置为 0</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;<span class="comment">// 找到了可运行的进程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">intr_on</span>();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">      <span class="comment">//如果没有找到可运行的进程，再次启用中断。</span></span><br><span class="line">      <span class="comment">//使用 wfi 指令（Wait For Interrupt）使CPU进入低功耗模式，等待中断</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened. 当被唤醒的时候需要锁</span></span><br><span class="line"><span class="comment">// 因为我们需要在更改当前进程的状态之前确保持有 p-&gt;lock，以避免竞争条件</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="comment">// 持有锁可以保证我们不错过任何wakeup,因为wakeup需要获取进程的锁</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    <span class="built_in">release</span>(lk);</span><br><span class="line">    <span class="comment">//如果传入的锁 lk 不是当前进程的锁 p-&gt;lock，则需要先获取当前进程的锁 p-&gt;lock</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sched</span>();<span class="comment">// 调用 sched 函数，让出CPU，允许调度器选择其他进程运行</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;<span class="comment">// 清理当前进程的等待通道 p-&gt;chan，将其设为 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="built_in">acquire</span>(lk);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果传入的锁 lk 不是当前进程的锁 p-&gt;lock，则需要重新获取传入的锁 lk。</span></span><br><span class="line"><span class="comment">    释放当前进程的锁 p-&gt;lock，然后重新获取传入的锁 lk，确保在返回时恢复原始的锁状态</span></span><br><span class="line"><span class="comment">    例如，某个资源的锁可能由多个进程共享，而不仅仅是当前进程的锁</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    在某些情况下，进程可能需要等待某个资源的释放，而这个资源的锁是由其他进程管理的</span></span><br><span class="line"><span class="comment">    通过传入这个资源的锁，可以在等待期间释放该锁，允许其他进程访问和操作该资源</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sched()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切换到调度器。必须只持有 p-&gt;lock 这是为了确保在切换上下文的时候当前进程的状态不会被其他线程修改</span></span><br><span class="line"><span class="comment">// 并且已经改变了 proc-&gt;state。保存和恢复 intena 是因为 intena 是这个</span></span><br><span class="line"><span class="comment">// 内核线程的属性，而不是这个 CPU 的属性。理想情况下应该是</span></span><br><span class="line"><span class="comment">// proc-&gt;intena 和 proc-&gt;noff，但这会在少数持有锁但没有进程的地方导致问题。</span></span><br><span class="line"><span class="comment">// intena是用于存储多层中断嵌套中最初始是否允许中断嵌套的信息</span></span><br><span class="line"><span class="comment">// noff用于中断嵌套的深度计数,表示中断被关闭且没有进行恢复的次数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用于将当前进程的控制权交还给调度器。</span></span><br><span class="line"><span class="comment">sched 函数主要用于在进程需要暂停执行时，保存当前进程的上下文，并恢复调度器的上下文，</span></span><br><span class="line"><span class="comment">以便调度器可以选择另一个进程运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holding</span>(&amp;p-&gt;lock))<span class="comment">// 确保当前进程持有自己的锁 p-&gt;lock</span></span><br><span class="line"><span class="comment">// 这是因为在调用 sched 之前，进程应该已经将自己的状态设置为 RUNNABLE 或 SLEEPING</span></span><br><span class="line"><span class="comment">// 并且持有自己的锁，以确保线程安全</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;noff != <span class="number">1</span>)</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      当noff为1时，表示当前中断已经被关闭了一次，并且没有其他层的中断关闭</span></span><br><span class="line"><span class="comment">      在调用sched()时，中断状态是确定的，不会被其他中断处理程序干扰</span></span><br><span class="line"><span class="comment">      如果noff大于1，可能意味着当前代码段已经在某个中断处理程序中，或者在某个临界区内</span></span><br><span class="line"><span class="comment">      在这种情况下，调用sched()可能会导致嵌套的上下文切换，进一步增加系统的复杂性和不稳定性</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">intr_get</span>())<span class="comment">// 确保当前没有中断发生</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = <span class="built_in">mycpu</span>()-&gt;intena;<span class="comment">// 保存当前CPU的中断使能状态</span></span><br><span class="line">  <span class="built_in">swtch</span>(&amp;p-&gt;context, &amp;<span class="built_in">mycpu</span>()-&gt;context);<span class="comment">// 切换上下文</span></span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;intena = intena;<span class="comment">// 恢复保存的中断使能状态intena</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于为什么中断处理过程中不可以进行进程切换"><a href="#关于为什么中断处理过程中不可以进行进程切换" class="headerlink" title="关于为什么中断处理过程中不可以进行进程切换"></a><strong><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/570708180">关于为什么中断处理过程中不可以进行进程切换</a></strong></h4><p>forkret()函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A fork child&#x27;s very first scheduling by scheduler()</span></span><br><span class="line"><span class="comment">// will swtch to forkret.</span></span><br><span class="line"><span class="comment">// 是在新创建的子进程第一次被调度器调度时调用</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">forkret</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> first = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// static关键字使得first变量在整个程序的生命周期中只初始化一次，并且在每次调用forkret时都保留其值。</span></span><br><span class="line"><span class="comment">// firs 变量用于标记是否是第一次调用 forkret</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Still holding p-&gt;lock from scheduler.</span></span><br><span class="line">  <span class="built_in">release</span>(&amp;<span class="built_in">myproc</span>()-&gt;lock);<span class="comment">// 释放当前进程的锁 p-&gt;lock，以便其他线程可以访问该进程的数据结构</span></span><br><span class="line">  <span class="comment">// 在调用 forkret 时，当前进程仍然持有 p-&gt;lock（即当前进程的锁）</span></span><br><span class="line">  <span class="comment">// 这是因为在调度器 scheduler 中调用 swtch 切换到新进程时，锁还没有释放</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    <span class="comment">// File system initialization must be run in the context of a</span></span><br><span class="line">    <span class="comment">// regular process (e.g., because it calls sleep), and thus cannot</span></span><br><span class="line">    <span class="comment">// be run from main().</span></span><br><span class="line">    first = <span class="number">0</span>;<span class="comment">// 将 first 设为 0，表示已经初始化过文件系统</span></span><br><span class="line">    <span class="built_in">fsinit</span>(ROOTDEV);<span class="comment">// 调用 fsinit(ROOTDEV) 初始化文件系统</span></span><br><span class="line">    <span class="comment">// 文件系统初始化需要在普通进程的上下文中进行，因为它可能调用 sleep 等函数</span></span><br><span class="line">    <span class="comment">// 而这些函数不能在 main 函数中直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">  <span class="comment">// 调用 usertrapret 函数，返回用户态</span></span><br><span class="line">  <span class="comment">// usertrapret 是一个汇编函数，用于从内核态返回用户态，恢复用户的上下文并继续执行用户程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是具体的任务了,源码的阅读到此为止</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog">i6bimua</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog/2024/11/01/MIT6-S081-LAB1/">https://i6biua.github.io/blog/2024/11/01/MIT6-S081-LAB1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://i6biua.github.io/blog" target="_blank">i6bimua</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/C/">C</a><a class="post-meta__tags" href="/blog/tags/xv6/">xv6</a></div><div class="post_share"><div class="social-share" data-image="/blog/img/bg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2024/11/02/LEETCODE3226/" title="LEETCODE3226"><img class="cover" src="/blog/img/kabuto.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LEETCODE3226</div></div></a></div><div class="next-post pull-right"><a href="/blog/2024/11/01/LEETCODE3259/" title="LEETCODE3259"><img class="cover" src="/blog/img/bg.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LEETCODE3259</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2024/10/22/MIT6-S081-LAB0/" title="MIT6.S081_LAB0"><img class="cover" src="/blog/img/kabuto.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-22</div><div class="title">MIT6.S081_LAB0</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">i6bimua</div><div class="author-info__description">天有雨</div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/i6biua"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天有雨</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#XV6-LAB"><span class="toc-number">1.</span> <span class="toc-text">XV6 LAB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-system-calls"><span class="toc-number">1.1.</span> <span class="toc-text">Lab2: system calls</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B91-%E9%94%81"><span class="toc-number">1.1.1.0.1.</span> <span class="toc-text">知识点1 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.1.1.0.1.1.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.1.0.1.2.</span> <span class="toc-text">锁的分类</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B92-chan"><span class="toc-number">1.1.1.0.2.</span> <span class="toc-text">知识点2 chan</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">源代码阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Memory-Management-Unit-MMU-%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%B3%E9%94%AE-%E9%A1%B5%E8%A1%A8%E6%98%AFMMU%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%8C%E5%AE%83%E7%BB%B4%E6%8A%A4%E4%BA%86%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E3%80%82"><span class="toc-number">1.1.2.0.0.1.</span> <span class="toc-text">Memory Management Unit (MMU)是虚拟内存管理的关键,页表是MMU的核心组成部分，它维护了虚拟地址与物理地址之间的映射关系。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#PGROUNDDOWN-PGROUNDUP%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.2.0.0.2.</span> <span class="toc-text">PGROUNDDOWN&amp;PGROUNDUP的解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%8D%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">关于为什么中断处理过程中不可以进行进程切换</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML"><img src="/blog/img/kon.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="hungyi_Lee_ML"/></a><div class="content"><a class="title" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML">hungyi_Lee_ML</a><time datetime="2025-04-20T14:04:16.000Z" title="发表于 2025-04-20 22:04:16">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258"><img src="/blog/img/bg.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3258"/></a><div class="content"><a class="title" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258">LEETCODE3258</a><time datetime="2024-11-12T14:18:13.000Z" title="发表于 2024-11-12 22:18:13">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE540"/></a><div class="content"><a class="title" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540">LEETCODE540</a><time datetime="2024-11-10T01:49:46.000Z" title="发表于 2024-11-10 09:49:46">2024-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255"><img src="/blog/img/kabuto.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3255"/></a><div class="content"><a class="title" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255">LEETCODE3255</a><time datetime="2024-11-06T01:36:01.000Z" title="发表于 2024-11-06 09:36:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3222"/></a><div class="content"><a class="title" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222">LEETCODE3222</a><time datetime="2024-11-05T04:57:18.000Z" title="发表于 2024-11-05 12:57:18">2024-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By i6bimua</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>