<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计组试题 | i6bimua</title><meta name="author" content="i6bimua"><meta name="copyright" content="i6bimua"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Which type of memory will need refresh circuitry. AA. DRAM       B. Flash       C. ROM       D. Blu-rayDRAM 除非被经常访问用于读&#x2F;写，否则不能长期保持其状态 The advantage of carry-lookahead adder is.DA. decrease cost o">
<meta property="og:type" content="article">
<meta property="og:title" content="计组试题">
<meta property="og:url" content="https://i6biua.github.io/blog/2024/10/28/%E8%AE%A1%E7%BB%84%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="i6bimua">
<meta property="og:description" content="Which type of memory will need refresh circuitry. AA. DRAM       B. Flash       C. ROM       D. Blu-rayDRAM 除非被经常访问用于读&#x2F;写，否则不能长期保持其状态 The advantage of carry-lookahead adder is.DA. decrease cost o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i6biua.github.io/blog/img/bg2.jpg">
<meta property="article:published_time" content="2024-10-28T04:30:00.000Z">
<meta property="article:modified_time" content="2024-11-22T06:54:14.000Z">
<meta property="article:author" content="i6bimua">
<meta property="article:tag" content="复习">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i6biua.github.io/blog/img/bg2.jpg"><link rel="shortcut icon" href="/blog/img/avatar.jpg"><link rel="canonical" href="https://i6biua.github.io/blog/2024/10/28/%E8%AE%A1%E7%BB%84%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计组试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-22 14:54:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/img/bg2.jpg')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="i6bimua"><span class="site-name">i6bimua</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">计组试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-28T04:30:00.000Z" title="发表于 2024-10-28 12:30:00">2024-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-22T06:54:14.000Z" title="更新于 2024-11-22 14:54:14">2024-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="计组试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/blog/img/bg2.jpg)"></div><article class="post-content" id="article-container"><ol>
<li>Which type of memory will need refresh circuitry. A<br>A. DRAM       B. Flash       C. ROM       D. Blu-ray<br>DRAM 除非被经常访问用于读&#x2F;写，否则不能长期保持其状态</li>
<li>The advantage of carry-lookahead adder is.D<br>A. decrease cost of the adder.       B. save hardware parts.<br>C. augment CPU clock frequency.       D. accelerate the generation of the carries.<br>carry-lookahead 就是为了减少加法器的延迟</li>
<li>In the direct addressing mode.B<br>A. The operand is inside the instruction.<br>B. The address of the operand is inside the instruction.<br>C. The register containing the address of the operand is specified inside the instruction.<br>D. The location of the operand is implicit.<br>直接寻址模式（Direct Addressing Mode）是一种计算机体系结构中常用的寻址方式。在这种模式下，指令中直接包含要访问的内存地址。这种方式简单直接，访问速度快，但也有一定的局限性。下面详细介绍直接寻址模式的概念、特点和使用场景。</li>
</ol>
<h3 id="直接寻址模式的定义"><a href="#直接寻址模式的定义" class="headerlink" title="直接寻址模式的定义"></a>直接寻址模式的定义</h3><p>在直接寻址模式中，指令中的地址字段直接指定了要访问的内存地址。处理器可以直接使用这个地址来读取或写入数据，而不需要进行任何额外的计算或转换。</p>
<h3 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h3><p>假设有一个简单的指令格式，其中地址字段直接指定了内存地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 操作码 | 地址 |</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>操作码</strong>：指示处理器执行的操作，如加载、存储等。</li>
<li><strong>地址</strong>：直接指定要访问的内存地址。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>简单直接</strong>：指令中的地址字段直接指定了内存地址，处理器可以直接使用这个地址进行访问，无需额外的计算。</li>
<li><strong>访问速度快</strong>：由于地址已经明确给出，处理器可以直接访问内存，减少了寻址时间。</li>
<li><strong>地址范围有限</strong>：地址字段的位数限制了可直接寻址的内存范围。例如，如果地址字段是 16 位，那么只能直接寻址 64KB 的内存空间。</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>小规模系统</strong>：在小型嵌入式系统或早期计算机中，内存容量较小，直接寻址模式足以满足需求。</li>
<li><strong>频繁访问固定地址</strong>：当程序需要频繁访问某些固定的内存地址时，直接寻址模式可以提高效率。</li>
<li><strong>简单控制逻辑</strong>：在需要简单控制逻辑的场合，直接寻址模式可以简化指令集和处理器设计。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有一个简单的指令集架构，其中有一条加载指令 <code>LOAD</code>，用于将内存中的数据加载到寄存器中。指令格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD R1, 1000</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>R1</strong>：目标寄存器，数据将被加载到这个寄存器中。</li>
<li><strong>1000</strong>：直接指定的内存地址。</li>
</ul>
<p>处理器执行这条指令时，会直接访问内存地址 1000，将该地址中的数据加载到寄存器 R1 中。</p>
<h3 id="与其他寻址模式的对比"><a href="#与其他寻址模式的对比" class="headerlink" title="与其他寻址模式的对比"></a>与其他寻址模式的对比</h3><ol>
<li><strong>间接寻址模式</strong>：指令中的地址字段指向一个内存位置，该位置存储了实际要访问的内存地址。</li>
<li><strong>基址寻址模式</strong>：指令中的地址字段与一个基址寄存器的值相加，得到实际的内存地址。</li>
<li><strong>相对寻址模式</strong>：指令中的地址字段相对于当前指令的地址进行偏移，得到实际的内存地址。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>直接寻址模式是一种简单高效的寻址方式，适用于内存容量较小或需要频繁访问固定地址的场景。尽管它的地址范围有限，但在许多嵌入式系统和简单控制系统中仍然非常有用。</p>
<ol start="4">
<li>In a microprogram-control computer, the microinstructions are stored in a memory called the.D<br>A. direct memory       B. physical memory       C. virtual memory       D. control store</li>
</ol>
<h3 id="5-5-控制信号"><a href="#5-5-控制信号" class="headerlink" title="5.5 控制信号"></a>5.5 控制信号</h3><p><img src="/blog/img/jz5-7.jpg"><br>处理器硬件组件的操作是由控制信号控制的，这些信号决定多路复用器要选择哪一个输入端，ALU 要执行什么样的操作等<br><strong>数据通路</strong><br><img src="/blog/img/jz5-4.jpg"></p>
<p><img src="/blog/img/jz5-8.jpg"><br>MuxB 选择寄存器 RB 中的内容或者是 IR 中的立即值<br>MuxY 端：</p>
<ul>
<li><strong>0 端口</strong> 如 add 命令第 4 阶段中没有处理动作，MuxY 选择 RZ 并且将计算结果传送给 RY，第 5 步中装入目的寄存器中</li>
<li><strong>1 端口</strong> 对于 Load&#x2F;Store 指令，ALU 在第三阶段计算出存储器操作数的有效地址并且装入 RZ。第 4 阶段该地址从 RZ 发送到存储器。对于 Load，MuxY 选择从存储器中读取的数据并且放入 RY，在第 5阶段传送给寄存器文件。对于 Store，数据在第 2 阶段从寄存器文件中被读出并且被放置到寄存器 RB中，RM 作为第 3，4 阶段的段间寄存器，在第 3阶段将 RB 中的内容传进 RM，在第 4 阶段将其存入存储器中，第 5 阶段无需采取任何动作</li>
<li><strong>2 端口</strong> 子程序调用指令把返回地址保存在一个通用寄存器中，称为 LINK。与之类似，中断处理也要保存返回地址。可以通过 MuxY 的第三个输入端将返回地址传送至寄存器 RY 然后发送到寄存器文件中。<br><img src="/blog/img/jz5-10.jpg"><br><strong>返回地址是由指令地址发生器产生的</strong><br>取指令时访问存储器的地址来自于 PC，在访问指令操作数时访问存储器的地址来自于寄存器 RZ。MuxMA 会选择 PC 或者 RZ 中的一个并发送到“处理器-寄存器”接口。指令地址发生器回在取出每条指令后对 PC 的内容进行更新，从存储器中读取的指令会被存储进 IR 直到其执行完毕且下一条指令被取出。<br><strong>控制电路可以检查 IR 的内容来生成控制处理器所有硬件所需的信号</strong><br>立即数模块也需要用到 IR 的内容，并且需要进行扩展到 32 位</li>
<li>算术运算指令进行符号扩展</li>
<li>其他指令例如逻辑运算指令用 0 进行填充<br>立即数模块负责生成扩展值，可以用于<strong>ALU 计算</strong>也可用于<strong>计算转移指令的目标地址</strong><br><strong>地址发生器</strong></li>
<li>在程序的线性执行中，加法器负责将 PC 递增 4</li>
<li>执行转移指令和子程序调用指令时，也可以用于计算一个将要被装入 PC 的新值<br>MuxINC 用于选择将常数 4 或者转移偏移量加到 PC 上。转移偏移量由立即数模块经过符号扩展之后给出。<br>MuxPC 在加法器的输出和寄存器 RA 的输出之间进行选择，LINK 用于在调用子程序或者中断的时候保存返回的地址，LINK寄存器的数据在第二阶段访问源寄存器的时候被放入RA<br>RA 一开始调用子程序的时候用于存放子程序开始的地址，PC 在第 3 阶段被装入 PC-Temp 之中，因为第 3 阶段无法直接写入寄存器文件，在第 5 阶段写入内置于控制电路中的寄存器 LINK 中。<strong>因为指令地址发生器中只有 RA 或者 4 可以连接到 MuxPC 然后被装入 PC 中</strong>，所以所有需要转移的指令都要先进入 RA，LINK 只是用于保存返回地址，但是最终还是需要放入 RA 才能实现转移<br>子程序返回命令将 LINK 中的内容放入 RA 中，再通过 MuxPC 放入 PC 中，中断指令除了使用不同的寄存器以外机制相同<br>寄存器 PC-Temp 用于临时存放 PC 的内容，并且通过 MuxY 传送给 RY 然后在第 5 阶段传输到寄存器文件中的 LINK 寄存器（通常）<br>数据在每个周期都从一个阶段传送到下一个阶段，所以段间寄存器总是处于启用状态，而其他寄存器 i.e.PC，IR 和寄存器文件在每个时钟周期内都保持不变，只有在特定的处理步骤中调用新的数据时才会启用<br>多路复用器的作用就是在任何阶段选择将要操作的数据<br><img src="/blog/img/jz5-18.jpg"><br><img src="/blog/img/jz5-20.jpg"><br>所需的控制信号如上图所示<br>寄存器文件有三个 5 位的地址输入端，可以访问 32 个通用寄存器，地址 A 和 B 用于确定将要读取的寄存器，与指令寄存器中的字段$IR_{31-27}和 IR_{26-22}$相连。第三个地址输入端地址 C 用于选择目的寄存器，端口 C 上的输入数据会被写入到该寄存器中新数据才会被装入所选择寄存器中<br>MuxC 和 MuxY 的控制信号需要两个位，因为需要从三个输入端中选择一个<br><img src="/blog/img/jz5-12.jpg"></li>
</ul>
<p>MuxC 用于选择地址 C 的来源，三寄存器指令使用 $IR_{21-17}$而其他指令使用 $IR_{26-22}$来指定目的寄存器。MuxC 的第三个输入端是子程序链接指令中使用的链接寄存器的地址，只有控制信号RF_write 发出后数据才会被装入所选择的寄存器中<br>一个<strong>k 位</strong>的控制码 ALU_op 确定了 ALU 要执行的运算，可以表示 $2^k$个不同的运算，比较器会产生指示比较结果的条件信号，控制电路通过检查条件信号确定转移条件是否成立<br>MEM_read 和 MEM_write 两个信号用于初始化存储器读或写操作，请求的操作完成后处理器-存储器接口会发出 MFC 信号（存储器功能完成信号）。<br>IR 通过收到控制信号 IR_enable 将一条新的指令装入寄存器，取指令阶段中该信号必须在 MFC 信号发出后才能被激活<br><strong>立即数</strong>模块需要处理三种可能的立即数形式：</p>
<ul>
<li>16 位符号扩展值</li>
<li>16 位无符号扩展值</li>
<li>26 位以特殊方式处理的值<br>26 位的值右边填充 2 个 0，左边用 PC 的 4 个高位进行扩展用于子程序调用指令</li>
</ul>
<h3 id="5-6-硬件控制"><a href="#5-6-硬件控制" class="headerlink" title="5.6 硬件控制"></a>5.6 硬件控制</h3><p>处理器产生所需的 1 控制信号有两种方式：</p>
<ul>
<li>硬件控制</li>
<li>微程序控制<br>指令按照一定的步骤序列进行执行，所以可以使用一个步计数器来跟踪执行的进度，在每一步内可以执行多个动作<br><strong>控制信号的设置取决于</strong>：</li>
<li>步计数器的内容</li>
<li>指令寄存器的内容</li>
<li>计算结果或比较操作的结果</li>
<li>外部输入信号，比如中断请求<br><img src="/blog/img/jz5-21.jpg"><br>信号 INS1 到 INSm 表示实现每条指令所需要的动作序列</li>
</ul>
<h4 id="5-7-2-微程序控制"><a href="#5-7-2-微程序控制" class="headerlink" title="5.7.2 微程序控制"></a>5.7.2 微程序控制</h4><p>由存储在特殊存储器中的一个程序来决定每一步中控制信号所需的设置，把该控制程序称为<strong>微程序</strong>。<br>微程序存储在处理器芯片上一个小型而快速的存储器中，该存储器被称为<strong>微程序存储器</strong>或者<strong>control store（控制存储器）</strong><br><strong>控制字&#x2F;微指令</strong>：用 n 位字中的每一位表示一个控制信号，其中每一位都制订了执行流中特定步的响应信号的设置。对于指令执行序列中的每一步都对应有一个控制字存储在微程序存储器（控制存储器）中<br>每个控制信号的值就是微指令中对应位的值<br><img src="/blog/img/jz5-27.jpg">)<br>与给定机器指令相对应的微指令序列构成了实现该指令的<strong>微例程</strong>。<strong>前两部被固定为取指令和指令译码的操作</strong>，从第三步开始微例程才和给定的机器指令相对应</p>
<p>微指令地址发生器对 IR 中的指令进行译码，以便得到相应微例程的起始地址<br>微指令中有一个 End 位标记最后一条微指令，End&#x3D;1 时地址发生器会返回到第一步对应的微指令，这样就可以取出一条新的机器指令</p>
<ol start="5">
<li>Consider a four bit ALU which does four bit arithmetic. When computing 1101 + 1011, what is the status of NZCV flags.<br><strong>NZCV flags</strong></li>
</ol>
<ul>
<li>N：negative，代表负数，如果结果是一个负数则这一位置为 1</li>
<li>Z：zero，代表结果是否为 0，如果结果为 0 则置为 1，非 0则为 0</li>
<li>C：</li>
<li>代表进位信号，如果$C_{n}$为 1 则置为 1，否则为 0</li>
<li>V：overflow，代表溢出，如果计算结果发生了溢出则置为 1，否则置为 0</li>
</ul>
<ol start="6">
<li>The pipelining technique typically improves the performance of a computer by.C<br>A. decreasing the execution time of an instruction       B. improving CPU block frequency<br>C. improving the throughput       D. decreasing the cache miss rate</li>
</ol>
<h2 id="第六章-流水线"><a href="#第六章-流水线" class="headerlink" title="第六章 流水线"></a>第六章 流水线</h2><h3 id="6-1-基本概念"><a href="#6-1-基本概念" class="headerlink" title="6.1 基本概念"></a>6.1 基本概念</h3><p>五个阶段对应图 5-7:</p>
<ul>
<li>取指令 Fetch</li>
<li>译码 Decode</li>
<li>计算 Compute</li>
<li>访存 Memory</li>
<li>写回 Write<br><img src="/blog/img/jz6-1.jpg"><br>流水线是一种<strong>重叠执行</strong>的模式<br>任何一条指令仍需要五个周期才能完成，但是指令是按<strong>每个周期</strong>一条的速率完成的</li>
</ul>
<h3 id="6-2-流水线结构"><a href="#6-2-流水线结构" class="headerlink" title="6.2 流水线结构"></a>6.2 流水线结构</h3><p><img src="/blog/img/jz6-2.jpg"><br>任何时间，流水线的每一个阶段都在处理不同的指令<br>随着每条指令进入下一个阶段，寄存器地址，立即数据和将要执行的操作之类的信息也必须背传送通过流水线，这些信息被保存在段间缓冲器中</p>
<ul>
<li>段间缓冲器 B1 向译码阶段提供一条新提取的指令</li>
<li>段间缓冲器 B2 向计算阶段提供从寄存器文件中读取的两个操作数，源&#x2F;目标寄存器标识符，来自指令的立即值，用作子程序调用返回地址的递增后的 PC 值，以及有指令译码器确定的控制信号的设置值</li>
<li>段间缓冲器 B3 保存 ALU 运算的结果，可能是即将写入寄存器文件的数据或者是送入访存阶段的一个地址。在 Store 时，B3 中保存要写入的数据，这些数据是在译码阶段从寄存器文件中读取的，存储在数据通路中的 RM 中。还保存从前一个阶段传递过来的递增后的 PC 值，以防需要它作为子程序调用指令的返回地址</li>
<li>段间缓冲器 B4 向写回阶段提供一个即将写入寄存器文件的值，可能是 ALU 的计算结果（第 3 阶段），也可能是存储器访问阶段（第 4 阶段）的结果，或者是作为返回地址写入 RA 的递增后的 PC 值</li>
</ul>
<ol start="7">
<li>The required control signals in a hardwired control unit are determined by the following information except. B<br>A. contents of the control step counter       B. contents of the MAR (memory address register)<br>C. contents of the IR (instruction register)       D. contents of the condition code flags<br>A 需要对每一步进行跟踪<br>C 是因为需要对于指令进行译码才能知道指令的具体内容，需要哪些控制信号<br>D 中的<strong>condition flags 即为条件码</strong>，就是 NCZV 等表示运算结果的条件位<br>运行时需要对这些信号进行检查才能知道接下来需要运行哪些指令，比如转移指令</li>
<li>The processor informs the IO devices that it is ready to acknowledge interrupts by.B<br>A. enabling the interrupt request line       B. activating the interrupt acknowledge line<br>C. activating the interrupt completion line       D. enabling the interrupt starting line</li>
</ol>
<h3 id="3-2-中断"><a href="#3-2-中断" class="headerlink" title="3.2 中断"></a>3.2 中断</h3><p>I&#x2F;O 设备在准备就绪时主动向处理器发送 interrupt request 硬件信号来告知处理器其已经准备就绪<br><strong>中断服务程序（interrupt-service routine）</strong>：响应中断请求时执行的程序，也就是执行中断之后跳转去执行的程序（发出中断请求的程序）<br>发生中断时，<strong>当前 PC 的内容指向第 i+1 条指令</strong>，这个地址被称为 return address 必须被保存在一个指定的通用寄存器或者处理器堆栈中<br>处理器必须通知设备它的请求已经被识别，让该设备撤销其中断请求信号，该控制信号被称为<strong>interrupt acknowledge</strong>信号<br><strong>interrupt latency</strong>：中断等待，从接收中断请求到开始执行中断服务程序之间的延迟，为了减少中断等待处理器通常只保存程序计数器和处理器状态寄存器的信息，剩下额外需要进行保存的内容都由显式的指令在中断服务程序开始时被保存，结束时被恢复</p>
<h4 id="3-2-1-中断的允许和禁止"><a href="#3-2-1-中断的允许和禁止" class="headerlink" title="3.2.1 中断的允许和禁止"></a>3.2.1 中断的允许和禁止</h4><p>处理器中有一个<strong>状态寄存器（status register，PS）</strong>，其中包含有关其当前操作状态的信息，该寄存器的一个位 IE 被分配用于允许&#x2F;禁止中断</p>
<ul>
<li>IE&#x3D;1 I&#x2F;O 设备的中断请求被处理器接受并处理</li>
<li>IE&#x3D;0 处理器简单地忽略所有 I&#x2F;O 设备的中断请求<br>I&#x2F;O 设备的接口包括一个控制寄存器，其中包含可以管理设备操作模式的信息，该寄存器的一个位专门用于中断控制，只有该位设置为 1 的时候 I&#x2F;O 设备才能被允许发出中断请求<br><img src="/blog/img/pcps.jpg"></li>
</ul>
<h4 id="3-2-2-处理多台设备"><a href="#3-2-2-处理多台设备" class="headerlink" title="3.2.2 处理多台设备"></a>3.2.2 处理多台设备</h4><p>当收到一个中断请求时，<strong>需要识别是哪一台设备发出的中断请求</strong>。并且如果有两台设备同时发出中断请求，<strong>必须</strong>选择其中一个进行处理。执行完选中设备的中断服务程序后，处理器才可以响应第二个中断请求**<br>当设备发出中断请求之后。它的状态寄存器中的一位被置为 1 这一位称为 IRQ 位，<br><strong>表示是否已经发出了中断请求且尚未被处理</strong>，使用轮询方式可以很简单的进行检查</p>
<ol>
<li>向量中断：请求中断的设备可以直接向处理器标明他自己，然后处理器就可以可以立即开始执行相应的中断服务程序<br>在存储器中永久的分配一个区域用于保存中断服务程序的地址，这些地址被称为<strong>中断向量</strong>，而中断向量构成一个<strong>中断向量表</strong><br>e.g. 分配 128 个字节用于保存一个包含 32 个中断向量的表</li>
<li>中断嵌套：I&#x2F;O 设备以一定的优先级结构组织起来，在处理低优先级的设备的中断请求的时候，高优先级设备的中断请求应当被接受<br>对于某些设备，过长的中断请求过长的延迟会导致错误的操作<br>例如<strong>时钟</strong>的中断请求<br>为了实现这种方式，我们可以给处理器分配一个优先级，其<strong>只在程序的控制下改变</strong>。处理器的优先级就是当前正在执行成粗的优先级，处理器只接受优先级高于它的设备的中断。优先级可以编码在处理器状态寄存器的某一些位中。<br>如果允许嵌套的中断，那么每一个中断服务程序都需要把 PC 和 PS（状态寄存器）中的内容保存在堆栈中，在中断服务程序把 PS 中的 IE 设置为 1 以允许中断之前完成</li>
<li>同时请求：处理器必须决定哪个请求最先被服务<br>轮询显然<br>使用向量中断时使用硬件电路支持保证只有一台设备发送其中断向量代码</li>
</ol>
<h4 id="3-2-3-控制-I-O-设备行为"><a href="#3-2-3-控制-I-O-设备行为" class="headerlink" title="3.2.3 控制 I&#x2F;O 设备行为"></a>3.2.3 控制 I&#x2F;O 设备行为</h4><p>需要控制设备是狗允许中断处理器，这种控制在设备的接口电路中通常以**中断允许位（IE）**的形式提供<br>在设备接口中提供一个控制寄存器，其中包含控制设备行为所需的信息，<strong>数据寄存器&#x2F;状态寄存器&#x2F;控制寄存器都可以作为一个可被寻址的单元进行访问</strong>。寄存器中的一位作为中断允许位。</p>
<h4 id="3-2-4-处理器控制寄存器"><a href="#3-2-4-处理器控制寄存器" class="headerlink" title="3.2.4 处理器控制寄存器"></a>3.2.4 处理器控制寄存器</h4><p><img src="/blog/img/jz3-7.jpg"><br>当收到一个中断请求并且接收其请求时，IPS 寄存器会自动保存 PS 寄存器的内容，在结束时也会传输回 PS 使其恢复以前状态，在中断嵌套中很重要<br>IENABLE 寄存器可以使处理器<strong>有选择的响应每个 I&#x2F;O 设备</strong><br>可以在 IENABLE 寄存器中为每个设备分配一位，当某位被置为 1 时处理器将接受所对应设备的中断请求。IPENDING 寄存器指示活跃的中断情求，当多个设备同时发出请求时将方便哪个中断应当首先被服务。<br>对于状态寄存器的内容有专门的指令<br><code>MoveControl IENABLE,R3</code><br>将 R3的内容放入 IENABLE 寄存器中，完成<strong>控制寄存器与通用寄存器之间</strong>的数据传输操作</p>
<ol start="9">
<li>The starting address sent by the device in vectored interrupt is called as.A<br>A. interrupt vector       B. location ID       C. service location       D. service ID</li>
<li>If the bytes 0x12, followed by 0x34, followed by 0x56, followed by 0x78 are interpreted as a 4-byte little endian integer, what value will they have.<br>0x78563412</li>
<li>Explain the process of DMA.<br>DMA（Direct Memory Access）<br>首先由处理器执行的程序初始化一个字块的传输，向 DMA 控制器发送起始地址，块内字数，传输方向等必要的信息，然后由 DMA 控制器对每一个传输的字提供存储器地址，产生需要的所有控制信号，为连续的字增加存储器地址并且累计已传输的字数。最后当整块数据传输完成之后 DMA 控制器产生一个中断信号通知处理器传输已经全部完成。</li>
</ol>
<h3 id="8-4-直接存储器访问"><a href="#8-4-直接存储器访问" class="headerlink" title="8.4 直接存储器访问"></a>8.4 直接存储器访问</h3><p>直接在主存和 I&#x2F;O 设备之间传输数据块<br>控制 DMA 传输的部件称为 <strong>DMA 控制器</strong>，访问主存时 DMA 控制器执行本来由处理器执行的功能。对每一个传输的字提供存储器地址，产生需要的所有控制信号，为连续的字增加存储器地址并且累计已传输的字数<br>DMA 的操作必须由处理器执行的程序控制，该程序一般是一个操作系统例程。<br>为了初始化一个字块的传输，处理器需要向 DMA 控制器发送起始地址,块内字数以及传输方向等信息。然后 DMA 控制器就开始执行所请求的操作。当整块数据传输完成之后其产生一个中断信号通知处理器。</p>
<ol start="2">
<li>Imagine a system with the following parameters. Virtual addresses 20 bits, physical addresses 18 bits, page size 1 KB. Please give the format of virtual address and physical address. Explain your answer.<br>1KB&#x3D;$2^{10}$Byte 所以需要 10 位作为偏移量<br>虚拟地址中剩下 10 位作为虚拟页号<br>物理地址中剩下 8 位作为页帧</li>
<li>The two numbers given below are multiplied using the Booth’s algorithm. Multiplicand: 0101101011101110. Multiplier: 0111011110111101. How many additions&#x2F;subtractions are required for the multiplication of the above two numbers.<br>01110111101111010<br>显然为 8 次</li>
<li>In a computer, can we build a memory system with one type of memory to get a large, fast and cheap memory.<br>不能，根据硬件原理，存储容量较大且造价低廉的存储器必然访问时间就更长，访问时间很短的存储器造价普遍很昂贵，存储容量相对较小。所以不能～。更好的方式是构建存储器的层次结构，这样对于计算机来说就好像是拥有了一个访问相对快速并且容量较大造价也较为适中的存储器。</li>
<li>Suppose we have a 7-bit computer that uses IEEE floating-point arithmetic where a floating point number has 1 sign bit, 3 exponent bits, and 3 fraction bits. The exponent part uses an excess-3 representation. The remaining 3-bit mantissa is normalized with an implied 1 to the left of the binary point. Rounding is employed as the truncation methal.<br>(1) Write the largest positive normalized floating-point number. And write the smallest positive normalized floating-point number.<br>(2) Write the result and computation process of A+B. Give the result in normalized form. A &#x3D; 1.001, B&#x3D; 0.010111.<br>（1）0 111 111&#x3D;1.111*$2^{7-3}$&#x3D;1.111*$2^{4}$&#x3D;11110&#x3D;30<br>0 000 000&#x3D;1.000*$2^{0-3}$&#x3D;0.125<br>（2）1.011111 运用 rounding 的截取方式得到 1.100<br>0 011 100</li>
<li>Is it possible to design an expanding opcode to allow the following to be encoded in a 12-bit instruction. Justify your answer. Assume a register operand requires 3 bits and this instruction set does not allow memory addresses to be directly used in an instruction.<br>(1) 6 instructions with 3 registers<br>三个寄存器需要 3*3&#x3D;9bit ，剩下 3bit 可以表示$2^{3}&gt;6$条指令<br>即开头为 000-101 是 3 寄存器命令<br>110 和 111 为高 3 位的不是 3 寄存器命令<br>(2) 14 instructions with 2 registers<br>高三位均为 110 或 111<br>两个寄存器需要 6bit，剩下 6bit-3bit&#x3D;3bit<br>这 3bit 还有 3 操作数指令剩下的 2 种有$2^{3}*2&#x3D;16$种 可能&gt;14，又剩下两位用作下一种指令<br>110000-110111 都是 2 寄存器命令，111000-111101 是 2 寄存器命令<br>111110 和 111111 用于小于 2 寄存器的命令<br>(3) 15 instructions with 1 register<br>111110000-111110111 都是 1 寄存器命令，111111000-111111110 都是 1 寄存器命令<br>剩下 111111111 是 0 寄存器命令<br>又用掉 15 条指令，剩下$2^{3}*2-15&#x3D;1$种用于表示无寄存器的命令<br>(4) 8 instructions with 0 register<br>都以 111111111 开头 111111111000-111111111111 一共 8 种<br>有$2^{3}&#x3D;8$种可能，刚好放得下<br>所以综上所述，足够表示</li>
<li>Part of a RISC-style processor’s datapath is shown as the following figure. Instruction execution can be divided into 5-stages. Now we want to execute Mutiply R7, R8, R9 on this datapath. Before this instruction, [R7]&#x3D;20, [R8]&#x3D;10, [R9]&#x3D;30. Write the values of registers at the end of instruction stage 2, stage 3, stage 4.   2.[RA],[RB].   3.[RZ].   4.[RY].<br>第二阶段是译码并且从寄存器文件中读取寄存器内容的阶段<br>[RA]&#x3D;10,[RB]&#x3D;30<br>第三阶段是 ALU 进行运算的阶段<br>[RZ]&#x3D;30*10&#x3D;300<br>第四阶段是进行存储器操作的阶段<br>[RY]&#x3D;300</li>
<li>The following sequence of RISC instructions are executed on a 5-stage pipeline. We can indicate the 5 stages of the pipeline using: F, D, C, M and W.   Add R2, R1, R3.   Sub R4, R2, R1   And R5, R1, R2   Sub R6, R2, R4<br>(1) Write all the data dependencies in the four instructions above.<br>sub 命令的源寄存器是 add 命令的目标寄存器，依赖于 add 命令<br>and 命令也同样依赖于 add 命令<br>第二个sub 命令既依赖于 add 命令也依赖于第一个 sub 命令<br>(2) Draw a figure to illustrate the execution of the four instructions on the pipeline. Assume that the pipeline has operand forwarding paths. Pay attention to mark the forwarding paths.</li>
</ol>
<h3 id="6-4-数据依赖性"><a href="#6-4-数据依赖性" class="headerlink" title="6.4 数据依赖性"></a>6.4 数据依赖性</h3><h4 id="6-4-1-操作数转发"><a href="#6-4-1-操作数转发" class="headerlink" title="6.4.1 操作数转发"></a>6.4.1 操作数转发</h4><p><strong>数据依赖性</strong>：一条指令的目标寄存器刚好是另一条指令的源操作数<br>但是实际上指令并不需要等到上一条指令完成后再开始执行，所需的值有可能在第三个周期的末尾 ALU 已经完成 Add 指令操作之后就可以使用了<br>这个值被装入寄存器 RZ 中，寄存器 RZ 是段间缓冲器 B3 的一部份，硬件可以将这个值转发至第 4 个周期中需要它的地方–ALU 的输入端而不必延迟下一条指令<br>e.g.<img src="/blog/img/jz6-4.jpg"><br><img src="/blog/img/jz6-5.jpg"></p>
<h4 id="6-4-2-用软件处理数据依赖性"><a href="#6-4-2-用软件处理数据依赖性" class="headerlink" title="6.4.2 用软件处理数据依赖性"></a>6.4.2 用软件处理数据依赖性</h4><p>让编译器检测和处理数据依赖性，在两条具有数据依赖性的指令之间插入显式的 NOP 空操作指令从而引入必要的延迟<br>为了减少延迟，编译器可以尝试优化代码，通过重新排序指令将有用的指令移到 NOP 槽中减少代码长度，但必须考虑到数据的依赖性<img src="/blog/img/jz6-4.jpg"></p>
<ol start="5">
<li>An integrated circuit RAM chip can hold 2048 words os 8 bits each (2k<em>8).<br>(1) How many addresses and the data lines are there in the chips.<br>11，8<br>(2) How many chips are needed to construct a 32k</em>16 RAM.<br>16<em>2&#x3D;32<br>(3) How many addresses and the data lines are there in a 32k</em>16 RAM.<br>15 address line<br>16 data line<br>(4) What size of the decoder is needed to construct 32k<em>16 memory from the 2k</em>8 chips. What are the inputs to the decoder and where are its outputs connected.<br>4-16 decoder<br>地址总线的高 4 位，连接到 16 片芯片的片选信号</li>
<li>A computer system uses 16-bit memory addresses. It has a 2k-byte cache organized in a direct-mapped manner with 64 bytes per cache block. Assume that the size of each memory word is 1 byte.<br>(1) Calculate the number of bits in each of the tag, block and word fields of the memory address.<br>cache 有 64 个 Byte$64&#x3D;2^{6}$所以需要 6bit 的 word<br>cache 中可以同时存储2k&#x2F;64&#x3D;32 个块，$32&#x3D;2^{5}$所以需要 5bit 的 block<br>tag&#x3D;16-6-5&#x3D;5bit<br><strong>如何验算</strong>：16bit 的计算机（说到了一个字一个 byte）按照按字寻址应该有$2^{16}$个 Byte，所以有$2^{16-6}&#x3D;2^{10}$个 block，又已知 cache 中有 32 个块，所以一共有 $2^{10-5}&#x3D;2^{5}&#x3D;32$个块<strong>会映射到同一个位置</strong>，tag 就是用来检查该块是否在 cache 中的，所以这 32 个块都需要有不同的 bit 段，很明显需要 5 个 bit，那么就是 tag&#x3D;5<br>(2) When a program is executed, the processor reads data sequentially from the following word addresses: 0080H, 0090H, 0880H, 0884H, 0080H, 0880H. Assume that the cache is initially empty. For each of the above addresses, indicate whether the cache access will result in a hit or a miss.<br>0000 0000 1000 0000 miss，然后这块索引为 00010 的块都被装入内存<br>0000 0000 1001 0000 块索引为 00010 在 cache 中，并且对比 tag 位也相同，所以为 hit<br>0000 1000 1000 0000 块索引为 00010，但 tag 位不同，miss，所以将原来的块进行替换<br>0000 1000 1000 0100 块索引 00010，tag 位相同 ，hit<br>0000 0000 1000 0000 块索引在，但是 tag 不同，miss，发生替换<br>0000 1000 1000 0000 块索引在，tag 不同，miss，发生替换<br>所以是：</li>
</ol>
<ul>
<li>miss</li>
<li>hit</li>
<li>miss</li>
<li>hit</li>
<li>miss</li>
<li>miss</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog">i6bimua</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog/2024/10/28/%E8%AE%A1%E7%BB%84%E8%AF%95%E9%A2%98/">https://i6biua.github.io/blog/2024/10/28/%E8%AE%A1%E7%BB%84%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://i6biua.github.io/blog" target="_blank">i6bimua</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E5%A4%8D%E4%B9%A0/">复习</a><a class="post-meta__tags" href="/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post_share"><div class="social-share" data-image="/blog/img/bg2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2024/10/29/LEETCODE3211/" title="LEETCODE3211"><img class="cover" src="/blog/img/ayanami.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LEETCODE3211</div></div></a></div><div class="next-post pull-right"><a href="/blog/2024/10/27/%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/" title="训练记录"><img class="cover" src="/blog/img/run.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">训练记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2024/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/" title="数据结构知识点"><img class="cover" src="/blog/img/mitsuha.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-31</div><div class="title">数据结构知识点</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">i6bimua</div><div class="author-info__description">天有雨</div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/i6biua"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天有雨</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">直接寻址模式的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.</span> <span class="toc-text">与其他寻址模式的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.</span> <span class="toc-text">5.5 控制信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">5.6 硬件控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">9.1.</span> <span class="toc-text">5.7.2 微程序控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number"></span> <span class="toc-text">第六章 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">6.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">6.2 流水线结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%B8%AD%E6%96%AD"><span class="toc-number">3.</span> <span class="toc-text">3.2 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%85%81%E8%AE%B8%E5%92%8C%E7%A6%81%E6%AD%A2"><span class="toc-number">3.1.</span> <span class="toc-text">3.2.1 中断的允许和禁止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%A4%84%E7%90%86%E5%A4%9A%E5%8F%B0%E8%AE%BE%E5%A4%87"><span class="toc-number">3.2.</span> <span class="toc-text">3.2.2 处理多台设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%8E%A7%E5%88%B6-I-O-%E8%AE%BE%E5%A4%87%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.3.</span> <span class="toc-text">3.2.3 控制 I&#x2F;O 设备行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">3.2.4 处理器控制寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E5%99%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">4.</span> <span class="toc-text">8.4 直接存储器访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">6.4 数据依赖性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E6%93%8D%E4%BD%9C%E6%95%B0%E8%BD%AC%E5%8F%91"><span class="toc-number">5.1.</span> <span class="toc-text">6.4.1 操作数转发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-number">5.2.</span> <span class="toc-text">6.4.2 用软件处理数据依赖性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="hungyi_Lee_ML"/></a><div class="content"><a class="title" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML">hungyi_Lee_ML</a><time datetime="2025-04-20T14:04:16.000Z" title="发表于 2025-04-20 22:04:16">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258"><img src="/blog/img/bg.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3258"/></a><div class="content"><a class="title" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258">LEETCODE3258</a><time datetime="2024-11-12T14:18:13.000Z" title="发表于 2024-11-12 22:18:13">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE540"/></a><div class="content"><a class="title" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540">LEETCODE540</a><time datetime="2024-11-10T01:49:46.000Z" title="发表于 2024-11-10 09:49:46">2024-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255"><img src="/blog/img/kabuto.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3255"/></a><div class="content"><a class="title" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255">LEETCODE3255</a><time datetime="2024-11-06T01:36:01.000Z" title="发表于 2024-11-06 09:36:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3222"/></a><div class="content"><a class="title" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222">LEETCODE3222</a><time datetime="2024-11-05T04:57:18.000Z" title="发表于 2024-11-05 12:57:18">2024-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By i6bimua</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>