<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构知识点 | i6bimua</title><meta name="author" content="i6bimua"><meta name="copyright" content="i6bimua"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第 2 章 算法分析$log^{k}N&#x3D;O(N)$ 第 3 章 基础 ADT3.5 List Array-based lists Pointer-based lists(Linked lists)  Array ImplementationInsert 12345678910&#x2F;&#x2F; insert element at the current positionvoid insert(cons">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构知识点">
<meta property="og:url" content="https://i6biua.github.io/blog/2024/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="i6bimua">
<meta property="og:description" content="第 2 章 算法分析$log^{k}N&#x3D;O(N)$ 第 3 章 基础 ADT3.5 List Array-based lists Pointer-based lists(Linked lists)  Array ImplementationInsert 12345678910&#x2F;&#x2F; insert element at the current positionvoid insert(cons">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i6biua.github.io/blog/img/mitsuha.jpg">
<meta property="article:published_time" content="2024-10-31T03:13:00.000Z">
<meta property="article:modified_time" content="2024-11-22T07:06:08.000Z">
<meta property="article:author" content="i6bimua">
<meta property="article:tag" content="数据结构与算法分析">
<meta property="article:tag" content="复习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i6biua.github.io/blog/img/mitsuha.jpg"><link rel="shortcut icon" href="/blog/img/avatar.jpg"><link rel="canonical" href="https://i6biua.github.io/blog/2024/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-22 15:06:08'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/blog/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/img/mitsuha.jpg')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="i6bimua"><span class="site-name">i6bimua</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-31T03:13:00.000Z" title="发表于 2024-10-31 11:13:00">2024-10-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-22T07:06:08.000Z" title="更新于 2024-11-22 15:06:08">2024-11-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">数据结构与算法分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(/blog/img/mitsuha.jpg)"></div><article class="post-content" id="article-container"><h2 id="第-2-章-算法分析"><a href="#第-2-章-算法分析" class="headerlink" title="第 2 章 算法分析"></a>第 2 章 算法分析</h2><p>$log^{k}N&#x3D;O(N)$</p>
<h2 id="第-3-章-基础-ADT"><a href="#第-3-章-基础-ADT" class="headerlink" title="第 3 章 基础 ADT"></a>第 3 章 基础 ADT</h2><h3 id="3-5-List"><a href="#3-5-List" class="headerlink" title="3.5 List"></a>3.5 List</h3><ul>
<li>Array-based lists</li>
<li>Pointer-based lists(Linked lists)</li>
</ul>
<h5 id="Array-Implementation"><a href="#Array-Implementation" class="headerlink" title="Array Implementation"></a>Array Implementation</h5><p>Insert</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert element at the current position</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Assert</span>(listSize&gt;=maxSize, “Exceed capacity”);</span><br><span class="line">  <span class="comment">//shift Elements up </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=listSize; i&gt;curr; i--)</span><br><span class="line">      listArray[i] = listArray[i<span class="number">-1</span>]; </span><br><span class="line">  listArray[curr] = it; <span class="comment">// insert the element</span></span><br><span class="line">  listSize++;  <span class="comment">// increment list size</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>remove</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove and return the current element</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Assert</span>((curr&gt;=<span class="number">0</span>)&amp;&amp;(curr&lt;listSize), <span class="string">&quot;no element&quot;</span>);</span><br><span class="line">  E it = listArray[curr]; <span class="comment">// Copy the element</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=curr; i&lt;listSize<span class="number">-1</span>; i++)</span><br><span class="line">    <span class="comment">// Shift them down</span></span><br><span class="line">       listArray[i] = listArray[i<span class="number">+1</span>];</span><br><span class="line">   listSize--;    <span class="comment">// Decrement size</span></span><br><span class="line">   <span class="keyword">return</span> it;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Pointer-Implementation"><a href="#Pointer-Implementation" class="headerlink" title="Pointer Implementation"></a>Pointer Implementation</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An implementation of a simple </span></span><br><span class="line"><span class="comment">// singly-linked list node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    E element;  <span class="comment">//value for this node</span></span><br><span class="line">    Link *next;   <span class="comment">//Pointer to next node in list</span></span><br><span class="line">    <span class="comment">//Constructors</span></span><br><span class="line">    <span class="built_in">Link</span>(<span class="type">const</span> E&amp; elemval, Link* nextval =<span class="literal">NULL</span>)</span><br><span class="line">    &#123;	element = elemval;  next = nextval; &#125;</span><br><span class="line">    <span class="built_in">Link</span>(Link* nextval =<span class="literal">NULL</span>)</span><br><span class="line">    &#123; next = nextval; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class LList </span></span><br><span class="line"><span class="comment">//inherit the abstract class List</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LList</span>: <span class="keyword">public</span> List&lt;E&gt;&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">  		Link&lt;E&gt;* head; <span class="comment">//Pointer to list header</span></span><br><span class="line">  		Link&lt;E&gt;* tail; <span class="comment">//Pointer to last element</span></span><br><span class="line">		Link&lt;E&gt;* curr; <span class="comment">//access to current element</span></span><br><span class="line">	 	<span class="type">int</span> cnt;      <span class="comment">//Size of list</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> <span class="comment">//used by constructor </span></span></span><br><span class="line"><span class="function">    	</span>&#123;  curr = tail = head = <span class="keyword">new</span> Link&lt;E&gt;; cnt =<span class="number">0</span>;&#125;		</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">removeall</span><span class="params">()</span> <span class="comment">//used by deconstructor</span></span></span><br><span class="line"><span class="function">		</span>&#123;   <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123; </span><br><span class="line">                 curr=head; head=head-&gt;next; <span class="keyword">delete</span> curr;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>insert</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Insert a node to current position</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123;</span><br><span class="line">		curr-&gt;next = <span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;(it, curr-&gt;next);  	</span><br><span class="line">  		<span class="keyword">if</span> (tail == curr) tail = curr-&gt;next; <span class="comment">//new tail</span></span><br><span class="line">		cnt++;</span><br><span class="line">	  &#125;</span><br><span class="line">    <span class="comment">//Append a node at the tail of the list</span></span><br><span class="line">	  <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123;</span><br><span class="line">  		tail = tail-&gt;next = <span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;(it, <span class="literal">NULL</span>);</span><br><span class="line">  		cnt++;</span><br><span class="line">  	  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>remove</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove and return current element 删除curr指针后的节点</span></span><br><span class="line">	<span class="function">E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		E it = curr-&gt;next-&gt;element;</span><br><span class="line">		Link&lt;E&gt; *ltemp = curr-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (tail == curr-&gt;next) </span><br><span class="line">			tail =curr; <span class="comment">// Reset tail</span></span><br><span class="line">		curr-&gt;next = curr-&gt;next-&gt;next; <span class="comment">//remove element</span></span><br><span class="line">		<span class="keyword">delete</span> ltemp;  <span class="comment">//reclaim space</span></span><br><span class="line">		cnt--;	   <span class="comment">//decrement the list size</span></span><br><span class="line">		<span class="keyword">return</span> it;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//Next – move curr one pos toward the tail</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="comment">// no change if already at end</span></span><br><span class="line"> 		<span class="keyword">if</span> (curr != tail) &#123; curr = curr-&gt;next;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//Prev – move curr one pos toward the head </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">prev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (curr == head) <span class="keyword">return</span>; <span class="comment">// No previous element</span></span><br><span class="line">     Link&lt;E&gt;* temp = head;</span><br><span class="line">	  <span class="comment">//march down list until the previous element</span></span><br><span class="line">	  <span class="keyword">while</span> (temp-&gt;next!=curr) temp=temp-&gt;next;</span><br><span class="line">  	  curr = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除列表中除表头节点以外的所有其他节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> List&lt;Type&gt; :: <span class="built_in">MakeEmpty</span> ( ) &#123;</span><br><span class="line">  ListNode&lt;Type&gt; *q;</span><br><span class="line">  <span class="keyword">while</span> (first-&gt;link!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"> q=first-&gt;link;</span><br><span class="line">   first-&gt;link=q-&gt;link;</span><br><span class="line">​     <span class="comment">//将表头结点后第一个结点从链中摘下</span></span><br><span class="line">​     <span class="keyword">delete</span> q;    <span class="comment">//释放它 </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 p-&gt;prev 和 p 之间插入一个新节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#123;val ,head ,tail&#125;</span></span><br><span class="line">p-&gt;prev=p-&gt;prev-&gt;next = <span class="keyword">new</span> Node&#123;x,p-&gt;prev,p&#125;；</span><br></pre></td></tr></table></figure>
<p>删除 p 指向的节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>在 itr 前插入 x</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">( iterator itr, Object &amp;&amp; x)</span></span>&#123;</span><br><span class="line">    Node *p = itr.current;</span><br><span class="line">    theSize++;</span><br><span class="line">    <span class="keyword">return</span> &#123; p-&gt;prev = p-&gt;prev-&gt;next = <span class="keyword">new</span> Node&#123;std::<span class="built_in">move</span>(x),p-&gt;prev,p&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除在 itr 处的项</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">( iterator itr)</span></span>&#123;</span><br><span class="line">    Node *p = itr.current</span><br><span class="line">    iterator retVal&#123;p-&gt;next&#125;;</span><br><span class="line">    p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    theSize--;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Comparison-of-List-Implementations"><a href="#Comparison-of-List-Implementations" class="headerlink" title="Comparison of List Implementations"></a>Comparison of List Implementations</h5><p>假设</p>
<ul>
<li>n为链表中现有的元素数量</li>
<li>p为指针所占用的大小</li>
<li>e为数据元素所占用的大小</li>
<li>d为数组最多能存储的元素个数</li>
</ul>
<p>数组实现的链表所需要占用的空间是de，指针链表所需要的空间是n（p+e）</p>
<p>当n&gt;de&#x2F;(p+e)的时候，使用数组实现的链表更加节省空间</p>
<h3 id="3-6-Stack"><a href="#3-6-Stack" class="headerlink" title="3.6 Stack"></a>3.6 Stack</h3><h5 id="计算后缀表达式"><a href="#计算后缀表达式" class="headerlink" title="计算后缀表达式"></a>计算后缀表达式</h5><p>使用一个栈，见到一个数时就把它推入栈中；在遇到一个运算符时该运算符就做用于从该栈弹出的两个数上，再将所得结果推入栈中<br>e.g. 6 5 2 3 + 8 * + 3 + * 每一次运算栈中的数字<br>6 5 2 3<br>6 5 5 8<br>6 45 3<br>6 48<br>288<br>时间复杂度为 O(N)</p>
<h5 id="中缀到后缀的转换"><a href="#中缀到后缀的转换" class="headerlink" title="中缀到后缀的转换"></a>中缀到后缀的转换</h5><p>当读到一个操作数的时候立即将其放到输出中。读到一个运算符的时候将运算符放到栈中，当遇到左圆括号时也要将其推入栈中。如果见到一个右括号就将栈元素弹出，直到遇到一个左括号为止，但是左括号只被弹出而不输出。<br>如果见到任何其他的符号，<strong>那么从栈中弹出栈元素并且写入输出直到发现优先级更低的元素为止（<strong>包括优先级相同的也要弹出并且输出</strong>），并且除非是处理“）”时，否则我们不从栈中移出“（”</strong>。当从栈中弹出元素的工作完成后，再将运算符压入栈中。<br>“（”在入栈的时候被认为有最高的优先级，在栈中时被认为具有最低的优先级，也就是说看到“（”就直接只入栈而不弹出其他运算符，并且除非看到“）”其不会被其他运算符出栈</p>
<h5 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h5><p>相当于是在数组实现的链表上加了一个限定的大小并进行了简化：只能在尾部进行操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; top=<span class="number">0</span>; &#125; 	<span class="comment">//Reinitialize</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123; 	<span class="comment">// put “it” on stack</span></span><br><span class="line">  <span class="built_in">Assert</span>(top != maxSize, “Stack is full”);</span><br><span class="line">  listArray[top++] = it; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span> </span>&#123;<span class="comment">//pop top element</span></span><br><span class="line">  <span class="built_in">Assert</span>(top != <span class="number">0</span>, “Stack is empty”);</span><br><span class="line">  <span class="keyword">return</span> listArray[--top]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> E&amp; <span class="title">topValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; 	<span class="comment">//return top element</span></span><br><span class="line">  <span class="built_in">Assert</span>(top != <span class="number">0</span>, “Stack is empty”);</span><br><span class="line">  <span class="keyword">return</span> listArray[top<span class="number">-1</span>]; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A linked stack </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">class</span> <span class="title class_">LStack</span>: <span class="keyword">public</span> Stack&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Link&lt;E&gt;* top;	<span class="comment">//pointer to first element</span></span><br><span class="line">	<span class="type">int</span> size; 		<span class="comment">//number of elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">LStack</span>(<span class="type">int</span> sz = defaultSize)&#123; 	<span class="comment">//Constructor            </span></span><br><span class="line">           top = <span class="literal">NULL</span>; size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">LStack</span>()  &#123; <span class="built_in">clear</span>(); &#125;		<span class="comment">//Destructor</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;			<span class="comment">//reinitialize</span></span><br><span class="line">	  <span class="keyword">while</span> (top != <span class="literal">NULL</span>) &#123; 	<span class="comment">//delete link nodes</span></span><br><span class="line">	      Link&lt;E&gt;* temp = top; top = top-&gt;next; <span class="keyword">delete</span> temp;</span><br><span class="line">	  &#125;</span><br><span class="line">	  size = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123; 	<span class="comment">//put “it” on the stack</span></span><br><span class="line">	   top = <span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;(it, top); size++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function">E <span class="title">pop</span><span class="params">()</span> </span>&#123; 				<span class="comment">//remove “it” from stack</span></span><br><span class="line">	  <span class="built_in">Assert</span>(top != <span class="literal">NULL</span>, “Stack is empty”);</span><br><span class="line">	  E it = top-&gt;element;</span><br><span class="line">	  Link&lt;E&gt;* ltemp = top-&gt;next;</span><br><span class="line">	  <span class="keyword">delete</span> top;  top = ltemp;  size--; <span class="keyword">return</span> it;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">const</span> E&amp; <span class="title">topValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; 	<span class="comment">//return top value</span></span><br><span class="line">	  <span class="built_in">Assert</span>(top != <span class="number">0</span>, “Stack is empty”);</span><br><span class="line">	  <span class="keyword">return</span> top-&gt;element;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>top指针指向第一个链表的节点</p>
<ul>
<li>push：手续爱你修改新创建的节点的next域，使其指向现在的栈的top指针指向的节点，然后移动top指针指向这个新的节点</li>
<li>pop：将top指针指向现在所指向的节点的next，然后释放原来节点的空间并且返回其值</li>
</ul>
<h3 id="3-7-Queue"><a href="#3-7-Queue" class="headerlink" title="3.7 Queue"></a>3.7 Queue</h3><p>运用循环数组实现队列</p>
<p>这里可以去看王道的书</p>
<p>front指向队头，而rear指向下一个可以插入元素的位置，所以初始时front&#x3D;rear</p>
<p><img src="/blog/img/looparray.jpg"></p>
<p><strong>PPT上的实现和王道书上的不同</strong></p>
<p>rear指向队尾元素，所以初始的时候rear+1&#x3D;&#x3D;front</p>
<p>但图片大致是对应的，只有一个单元的差距</p>
<ul>
<li><p>front &#x3D; rear 队列中只有一个元素</p>
</li>
<li><p>front &#x3D; rear + 1 怎么判断队列是空的还是满的<br>Solution：<br>1.显式的记录有多少个在队列中的元素<br>2.让数组的大小为 n+1 但是只允许最多存储 n 个元素</p>
</li>
<li><p>当 front &#x3D; rear+1 时，队列为空</p>
</li>
<li><p>当 front &#x3D; rear+2 时，队列为满<br>队列的长度为（（rear+maxSize）-front+1）%maxSize</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Array-based Implementation (solution 2)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">class</span> <span class="title class_">AQueue</span>: <span class="keyword">public</span> Queue&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> maxSize; <span class="comment">// Maximum size of queue</span></span><br><span class="line"><span class="type">int</span> front; <span class="comment">// Index of front element</span></span><br><span class="line"><span class="type">int</span> rear; <span class="comment">// Index of rear element</span></span><br><span class="line">E *listArray; <span class="comment">//Array holding queue elements</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">AQueue</span>(<span class="type">int</span> size =defaultSize) &#123; </span><br><span class="line"><span class="comment">// Constructor- Make list array one position</span></span><br><span class="line"><span class="comment">// larger for empty slot</span></span><br><span class="line">	maxSize = size<span class="number">+1</span>;</span><br><span class="line">	rear = <span class="number">0</span>; front = <span class="number">1</span>;</span><br><span class="line">	listArray = <span class="keyword">new</span> E[maxSize];</span><br><span class="line">&#125;</span><br><span class="line">˜ <span class="built_in">AQueue</span>() &#123; <span class="keyword">delete</span> [] listArray; &#125;</span><br><span class="line"><span class="comment">//reinitializeS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;rear = <span class="number">0</span>;  front = <span class="number">1</span>;&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enqueue</span><span class="params">(<span class="type">const</span> E&amp; it)</span> </span>&#123;<span class="comment">//put “it” in queue</span></span><br><span class="line">  <span class="built_in">Assert</span>(((rear<span class="number">+2</span>) % maxSize) != front, </span><br><span class="line">“Queue is full”);</span><br><span class="line">  rear = (rear<span class="number">+1</span>)%maxSize;</span><br><span class="line">  listArray[rear] = it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;<span class="comment">//take element out</span></span><br><span class="line">  <span class="built_in">Assert</span>(<span class="built_in">length</span>() != <span class="number">0</span>, “Queue is empty”);</span><br><span class="line">  E it = listArray[front];</span><br><span class="line">  front =(front<span class="number">+1</span>)%maxSize; </span><br><span class="line">  <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//get front value</span></span><br><span class="line"><span class="function"><span class="type">const</span> E&amp; <span class="title">frontValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">  <span class="built_in">Assert</span>(<span class="built_in">length</span>()!=<span class="number">0</span>, “Queue is empty”);</span><br><span class="line">  <span class="keyword">return</span> listArray[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return length</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((rear+maxSize)-front<span class="number">+1</span>)%maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="第-4-章-Tree"><a href="#第-4-章-Tree" class="headerlink" title="第 4 章 Tree"></a>第 4 章 Tree</h2><p>一棵树中从根到每个节点恰好存在一条路径</p>
<h6 id="构造一棵表达式树"><a href="#构造一棵表达式树" class="headerlink" title="构造一棵表达式树"></a>构造一棵表达式树</h6><p>将后缀表达式转换为表达式树<br>如果符号是操作数，就建立一个单节点树并且将指向它当指针推入栈<br>如果符号是操作符，那么从栈中弹出指向两棵树$T_{1},T_{2}$的两棵树的指针，先弹出的为 $T_{1}$并且形成一棵新的树，该树的根为操作数，其左右儿子分别为$T_{2}和 T_{1}$，然后将指向这棵新树的指针压入栈中</p>
<h3 id="4-3-二叉查找树"><a href="#4-3-二叉查找树" class="headerlink" title="4.3 二叉查找树"></a>4.3 二叉查找树</h3><h4 id="4-3-4-remove"><a href="#4-3-4-remove" class="headerlink" title="4.3.4 remove"></a>4.3.4 remove</h4><ul>
<li>无儿子：直接删除</li>
<li>一个儿子：让其父节点直接指向其儿子</li>
<li>两个儿子的情况：<br>用其右子树中的最小的数据代替该节点的数据并且，并且递归地删除该节点。<br>由于右子树中最小的节点不可能有左儿子，所以第二次的 remove 会容易很多<br><img src="/blog/img/sjjg4-25.jpg"><br><strong>lazy remove</strong>：不实际删除节点而是只作了被删除的标记<br><img src="/blog/img/sjjg4-26.jpg"></li>
</ul>
<h3 id="4-4-AVL-树"><a href="#4-4-AVL-树" class="headerlink" title="4.4 AVL 树"></a>4.4 AVL 树</h3><p>每个节点的左右子树高度最多相差 1（空树的高度为-1）</p>
<h4 id="4-4-1-单旋转"><a href="#4-4-1-单旋转" class="headerlink" title="4.4.1 单旋转"></a>4.4.1 单旋转</h4><p><img src="/blog/img/sjjg4-42.jpg"><br>左侧双旋转为先左旋转再右旋转<br>右侧双旋转为先右旋转再左旋转<br><img src="/blog/img/sjjg4-44.jpg"><br><strong>右旋转操作（WithLeftChild)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Rotate binary tree node with left child.</span></span><br><span class="line"><span class="comment">* For AVL trees, this is a single rotation for case 1.</span></span><br><span class="line"><span class="comment">* Update heights, then set new root.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotateWithLeftChild</span><span class="params">( AvlNode * &amp; k2 )</span></span>&#123;</span><br><span class="line">    AvlNode *k1 = k2-&gt;left; </span><br><span class="line">    k2-&gt;left = k1-&gt;right; <span class="comment">//将 k1 的右子树移交给 k2</span></span><br><span class="line">    k1-&gt;right = k2; <span class="comment">/*由于最后需要把 k1 连接到父节点，所以父子关系需要改变，所以将 k1 的右子树连接到 k2 */</span></span><br><span class="line">    k2-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>( k2-&gt;left ), <span class="built_in">height</span>( k2-&gt;right ) ) + <span class="number">1</span>;</span><br><span class="line">    k1-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>( k1-&gt;left ), k2-&gt;height ) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//k2-&gt;height 其实就是 k1 右子树的高</span></span><br><span class="line">    k2 = k1;</span><br><span class="line">    <span class="comment">//让父节点指向 k1，因为在参数列表传递的是指针的引用，所以会对上一个节点传下来的指针进行改动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有插入或者删除操作结束后都要记得加上 balance（t）<br><strong>balance</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">balance</span><span class="params">( AvlNode * &amp; t )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( t == <span class="literal">nullptr</span> )  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">height</span>(t-&gt;left) - <span class="built_in">height</span>(t-&gt;right) &gt; IMBALANCE )</span><br><span class="line">       <span class="keyword">if</span>( <span class="built_in">height</span>( t-&gt;left-&gt;left ) &gt;= <span class="built_in">height</span>( t-&gt;left-&gt;right ) )</span><br><span class="line">           <span class="built_in">rotateWithLeftChild</span>( t );</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">doubleWithLeftChild</span>( t );</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">if</span>( <span class="built_in">height</span>( t-&gt;right ) - <span class="built_in">height</span>( t-&gt;left ) &gt; IMBALANCE )</span><br><span class="line">       <span class="keyword">if</span>( <span class="built_in">height</span>( t-&gt;right-&gt;right ) &gt;= <span class="built_in">height</span>( t-&gt;right-&gt;left ) )</span><br><span class="line">           <span class="built_in">rotateWithRightChild</span>( t );</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">doubleWithRightChild</span>( t );</span><br><span class="line">  t-&gt;height = <span class="built_in">max</span>( <span class="built_in">height</span>( t-&gt;left ), <span class="built_in">height</span>( t-&gt;right ) ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-splay"><a href="#4-5-splay" class="headerlink" title="4.5 splay"></a>4.5 splay</h3><h4 id="4-5-2-展开"><a href="#4-5-2-展开" class="headerlink" title="4.5.2  展开"></a>4.5.2  展开</h4><p><img src="/blog/img/sjjg4-49.jpg"></p>
<ul>
<li>如果是 zig-zag 情况就对应执行一次相应的双旋转</li>
<li>如果是 zig-zig 情况就进行两次方向相同的单旋转操作<br><strong>Insert 先正常插入后将 x  splay 到根</strong><br><strong>Delete</strong>：</li>
</ul>
<ol>
<li>将 x  splay 到根后将其删除</li>
<li>将左子树的中的最大值splay 到左子树的根</li>
<li>将右子树连接到左子树新的根上</li>
</ol>
<h3 id="4-7-B-Tree"><a href="#4-7-B-Tree" class="headerlink" title="4.7 B-Tree"></a>4.7 B-Tree</h3><p>阶为 M 的 B 树具有以下的性质：</p>
<ul>
<li>数据项存储在树叶上</li>
<li>非叶子节点存储知道 M-1 个关键字以指示搜索的方向；关键字 i 代表子树 i+1 中的最小的关键字</li>
<li>树的根要么是一片树叶要么儿子数介于 2-M 之间</li>
<li>除根外所有非叶子节点的儿子数在 $\lceil M&#x2F;2 \rceil$和 M 之间</li>
<li>所有的树叶都在相同的深度上，并且每片树叶拥有的数据项个数在$\lceil L&#x2F;2 \rceil$和 L 之间<br>插入叶子节点和插入内部节点有一些地方是不相同的</li>
</ul>
<ol>
<li>首先是 L 和 M 的不同，叶子节点对应 L，内部节点对应 M</li>
<li>其次叶子节点在分裂的时候分成两部分，$j&#x3D;\lfloor {L+1}&#x2F;2 \rfloor$个记录在左边叶子，剩下的在右边叶子，右边叶子的第一个记录被插入父节点。而内部节点将 j-1 个 keys放在左边，第 j 个 key 插入父节点，剩下的 keys 放在右边节点<br><strong>分裂完大部分都是右节点较重</strong><br><strong>B 树具体的操作过程必须看笔记和 PPT牢记</strong></li>
</ol>
<h6 id="Delete-x"><a href="#Delete-x" class="headerlink" title="Delete x"></a>Delete x</h6><p>进行一次查找并且从叶子节点处进行删除</p>
<ul>
<li>如果叶节点 underflow，可以从邻居处领养</li>
<li>如果叶节点 underflow 且不可领养，那么将节点进行合并，然后对父节点继续进行 delete，因为这会导致父节点的儿子数减少 1<br>内部存储适合小阶数，例如 3&#x2F;4<br>磁盘中选择最大的 M，使得内部节点可以被存储在硬盘上的一个物理上的块之中</li>
</ul>
<h2 id="第-5-章-散列"><a href="#第-5-章-散列" class="headerlink" title="第 5 章 散列"></a>第 5 章 散列</h2><h3 id="5-3-分离链接法-separate-chaining"><a href="#5-3-分离链接法-separate-chaining" class="headerlink" title="5.3 分离链接法 separate chaining"></a>5.3 分离链接法 separate chaining</h3><p>将散列到同一个值的所有元素保留到一个链表中<br><strong>装载因子</strong>：散列表中的元素个数对于该表大小的比值<br><strong>Insert</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">( <span class="type">const</span> HashedObj &amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp; whichList = theLists[ <span class="built_in">myhash</span>(x) ];</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">find</span>( <span class="built_in">begin</span> ( whichList), <span class="built_in">end</span>(whichList),x) != <span class="built_in">end</span>(whichList ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    whichList.<span class="built_in">push_back</span>(x);</span><br><span class="line">    <span class="keyword">if</span>( ++currentSize &gt; theLIsts.<span class="built_in">size</span>() )</span><br><span class="line">        <span class="built_in">rehash</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分离链接法的一般法则是让 $\lambda\approx1$<br>$\lambda$就是所有链表的平均长度，所以访问一个项目的平均时间为$O(1)+O(\lambda)$</p>
<h3 id="5-4-不用链表的散列表-Open-Addressing"><a href="#5-4-不用链表的散列表-Open-Addressing" class="headerlink" title="5.4 不用链表的散列表 Open Addressing"></a>5.4 不用链表的散列表 Open Addressing</h3><p>所有的 keys 都存在于表中<br>当我们寻找值 x 的时候，按顺序搜索位置 $h_{0}(x),h_{1}(x),…$直到</p>
<ul>
<li>找到 x</li>
<li>发现了一个空的位置（说明 x 不存在）<br><strong>Insert 和 Search 所使用的应当是同一个 probe sequence 探测序列</strong><br><strong>对于不使用分离链接法的散列表而言其装填因子应该低于 $\lambda &#x3D; 0.5$</strong><br>这样的表叫做<strong>探测散列表（probing hash table）</strong><br>$h_{i}(X)&#x3D;(Hash(X)+p(X,i)) mod TableSize$<br><strong>并且定义 $p（X，0）&#x3D;0$</strong></li>
<li>Linear：$p(X,i)&#x3D;i$</li>
<li>Quadratic: $p(X,i)&#x3D;i^{2}$</li>
<li>Double Hashing: $p(X,i)&#x3D;i*Hash_{2}(X)$</li>
<li>Pseudo-random probing</li>
</ul>
<h4 id="5-4-1-线性探测法"><a href="#5-4-1-线性探测法" class="headerlink" title="5.4.1 线性探测法"></a>5.4.1 线性探测法</h4><p>$f(i)&#x3D;i$  即 $f 为 i 的线性函数$<br>即搜索序列为 $Hash(K),Hash(K)+1,Hash(K)+2,… mod TableSize$<br>当元素开始占据相邻的位置后，会形成一些区块，这种现象称为<strong>一次聚集（Primary Clustering）</strong><br><strong>Primary clustering</strong>：散列到不同位置的元素探测一系列同样的的替代位置<br>改进的方式是在 i 前乘一个常数 c，c 应当是一个与 M 互质的数字</p>
<h4 id="Peseudo-random-probing"><a href="#Peseudo-random-probing" class="headerlink" title="Peseudo-random probing"></a>Peseudo-random probing</h4><ul>
<li>$p(K,i) &#x3D; Perm[i-1]</li>
<li>第 i 个探测序列中探测的 slot 为$(h(K) + Perm[i-1]) % M$</li>
<li>所有的插入和查询操作都使用同样的 random permutation</li>
</ul>
<h4 id="5-4-2-平方探测法-Quadratic-Probing"><a href="#5-4-2-平方探测法-Quadratic-Probing" class="headerlink" title="5.4.2 平方探测法 Quadratic Probing"></a>5.4.2 平方探测法 Quadratic Probing</h4><p>$f(i) &#x3D; i^{2}$<br>$p(K,i) &#x3D; c_{1}i^{2} + c_{2}i +c_{3}$<br><strong>如果使用平方探测并且表的大小为素数的时候，那么当表至少有一半为空时，即 $\lambda \leq 0.5 $的时候总是能够插入一个新的元素</strong><br>探测散列表中不能施行删除操作，因为很有可能该单元引起过冲突，而元素绕过该单元存在了别处，如果将该单元中的元素删除那么剩下的 find 操作会先找到一个空的位置导致 find 操作失败，所以只能标记该位置已经被删除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> HashedObj &amp; x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> <span class="built_in">isActive</span>( <span class="built_in">findPos</span>( x) );&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findPos</span><span class="params">( <span class="type">const</span> HashedObj &amp; x)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> offset=<span class="number">1</span>; <span class="comment">//初始的偏移量为 1</span></span><br><span class="line">    <span class="type">int</span> currentPos = <span class="built_in">myhash</span> ( x );</span><br><span class="line">    <span class="keyword">while</span>( array[ currentPos ].info != EMPTY &amp;&amp;</span><br><span class="line">             array[ currentPos ].element != x)</span><br><span class="line">    &#123;</span><br><span class="line">        currentPos += offset; <span class="comment">//计算第 i 次探测</span></span><br><span class="line">        offset += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( currentPos &gt;= array.<span class="built_in">size</span>() ) currentPos -= array.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currentPos;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>$f(i)&#x3D;f(i-1)+2i-1$这个公式说明下一个尝试的单元离上一个被试过的单元有一段距离，并且这个距离在连续探测中每次递增 2<br>虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元，叫做<strong>二次聚集（secondary clustering）</strong><br>二次聚集的现象在伪随机和平方探测法中仍然存在</p>
<h4 id="5-4-3-双散列-double-hashing"><a href="#5-4-3-双散列-double-hashing" class="headerlink" title="5.4.3 双散列 double hashing"></a>5.4.3 双散列 double hashing</h4><p>$f(i)&#x3D;i<em>hash_{2}(x)$<br>探测位置$h_{1}(X),h_{1}(X)+h_{2}(X),h_{1}(X)+2</em>h_{2}(X), … mod$ $TableSize$<br>$p(X,i) &#x3D; i*h_{2}(K)$</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>分离链接法简单但是浪费空间</li>
<li>线性探测法更好的利用了空间，在表为稀疏的时候比较快速</li>
<li>双散列高效利用了空间，也很快，但是需要很谨慎的实现<br>$h_{2}(X)$不可以是 0 也不可以是 M 的因子</li>
</ul>
<h3 id="5-5-再散列"><a href="#5-5-再散列" class="headerlink" title="5.5 再散列"></a>5.5 再散列</h3><p>建立另外一个大约两倍大的表，并且使用一个相关的新散列函数，扫描整个原始散列表，计算每个为删除的元素的新散列值并将其插入到新表中<br><strong>不可以只是从旧表中 copy 数据，因为表有一个新的散列函数</strong><br>运行时间为 $O(N)$<br>可以表满到一半就再散列，也可以只有发生插入失败时才再散列<br><strong>middle-of-the-road strategy</strong>：当散列表到达某一特定的装填因子时进行再散列（是目前最好的策略）<br><strong>最好设计一个散列表系统永远不会超过半满</strong><br>减少面对冲突时产生的开销：</p>
<ul>
<li>如果两个记录被散列到同一个初始位置，被访问的频率更高的记录应该被放在初始位置</li>
<li>探测序列所访问的记录按照被访问频率进行排序</li>
</ul>
<h2 id="第-6-章-优先队列-堆"><a href="#第-6-章-优先队列-堆" class="headerlink" title="第 6 章 优先队列&#x2F;堆"></a>第 6 章 优先队列&#x2F;堆</h2><h3 id="6-3-二叉堆"><a href="#6-3-二叉堆" class="headerlink" title="6.3 二叉堆"></a>6.3 二叉堆</h3><p>堆有两个性质，结构性和堆序性</p>
<h4 id="6-3-1-结构性质"><a href="#6-3-1-结构性质" class="headerlink" title="6.3.1 结构性质"></a>6.3.1 结构性质</h4><p>堆是一颗完全二叉树，除底层外都被填满，底层上的元素从左到右填入<br>因为完全二叉树的规律性，所以可以用一个数组表示<br>对于数组中任一位置$i$上的元素，其儿子在 $2i,2i+1$位置，其父亲在$\lfloor i&#x2F;2 \rfloor$</p>
<h4 id="6-3-2-堆序性质"><a href="#6-3-2-堆序性质" class="headerlink" title="6.3.2 堆序性质"></a>6.3.2 堆序性质</h4><p><strong>任意节点都小于（或等于）其所有后裔</strong><br>对于每一个节点 X，X 的父亲中的关键字小于或等于 X 中的关键字</p>
<h4 id="6-3-3-基本的堆操作"><a href="#6-3-3-基本的堆操作" class="headerlink" title="6.3.3 基本的堆操作"></a>6.3.3 基本的堆操作</h4><p><strong>Insert</strong>：precolate up<br>在下一个可用位置创建一个空穴，如果 X 可以放入空穴而不破坏堆序性质那么就直接放入，否则将空穴的父节点上的元素移入该空穴中，直到 X 能够被放入空穴中为止<br><strong>percolate up</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span> <span class="params">( <span class="type">const</span> Comparable &amp; x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( currentSize == array.<span class="built_in">size</span>() - <span class="number">1</span> )</span><br><span class="line">        array.<span class="built_in">resize</span>( array.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 上滤</span></span><br><span class="line">    <span class="type">int</span> hole = ++currentSize;</span><br><span class="line">    Comparable copy = x;</span><br><span class="line">    </span><br><span class="line">    array[ <span class="number">0</span> ] = std::<span class="built_in">move</span>( copy );</span><br><span class="line">    <span class="comment">//数组从位置 1 开始，所以放在 0 处防止越界</span></span><br><span class="line">    <span class="keyword">for</span>( ; x &lt; array[ hole / <span class="number">2</span>]; hole /= <span class="number">2</span>)</span><br><span class="line">        array[ hole ] = std::<span class="built_in">move</span>( array [ hole / <span class="number">2</span> ] );</span><br><span class="line">    array[ hole ] = std::<span class="built_in">move</span>( array[ <span class="number">0</span> ] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>deleteMin</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteMIn</span><span class="params">( comparable &amp; minItem )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">isEmpty</span>() ) <span class="keyword">throw</span> UnderflowException&#123; &#125;;</span><br><span class="line">    minItem = std::<span class="built_in">move</span>( array[ <span class="number">1</span> ] );</span><br><span class="line">    array[ <span class="number">1</span> ] = std::<span class="built_in">move</span>( array[ currentSize-- ] );</span><br><span class="line">    <span class="built_in">percolateDown</span>( <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">percolateDown</span><span class="params">( <span class="type">int</span> hole )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    Comparable tmp = std::<span class="built_in">move</span>( array[ hole ] );</span><br><span class="line">    <span class="keyword">for</span>( ; hole * <span class="number">2</span> &lt;= currentSize; hole = child )&#123;</span><br><span class="line">        child = hole * <span class="number">2</span>;<span class="comment">//左儿子</span></span><br><span class="line">        <span class="keyword">if</span>( child != currentSIze &amp;&amp; array[ child + <span class="number">1</span> ] &lt;array [ child ] )</span><br><span class="line">            ++child;<span class="comment">//右儿子</span></span><br><span class="line">        <span class="keyword">if</span>( array[ child ] &lt; tmp ) array[ hole ] = std::<span class="built_in">move</span>( array[ child ] );<span class="comment">//向下</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[ hole ] = std::<span class="built_in">move</span>( tmp );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-4-其他的堆操作"><a href="#6-3-4-其他的堆操作" class="headerlink" title="6.3.4 其他的堆操作"></a>6.3.4 其他的堆操作</h4><p><strong>buildHeap</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = currentSize / <span class="number">2</span>; i &gt; <span class="number">0</span>; --i）<span class="comment">//从最右边的叶子节点的父亲开始向前的所有节点都执行下滤操作</span></span><br><span class="line">        <span class="built_in">percolateDown</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$时间复杂度为 O（N）$</p>
<h2 id="第-7-章-排序"><a href="#第-7-章-排序" class="headerlink" title="第 7 章 排序"></a>第 7 章 排序</h2><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul>
<li><strong>选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法。</strong></li>
<li><strong>冒泡排序、插入排序、归并排序、基数排序是稳定的排序算法。</strong></li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  Selection Sort</span></span><br><span class="line"><span class="comment">*  In the ith pass, the ith smallest key in the array is selected * and placed into position i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selsort</span><span class="params">(E A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123; <span class="comment">//select ith record</span></span><br><span class="line">    <span class="type">int</span> lowindex = i; <span class="comment">//Remember its index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i; j--) <span class="comment">//Find least value</span></span><br><span class="line">    <span class="comment">//找到从第 i+1 个数字到尾部数字中的最小值</span></span><br><span class="line">    <span class="comment">// 每次都将第 i 个最小的元素放在其应当放在的位置</span></span><br><span class="line">    <span class="comment">// 假如有两个相同大的数放在不同位置很显然其相对次序会被打乱，所以选择排序并不是稳定的</span></span><br><span class="line">      <span class="keyword">if</span> (Comp::<span class="built_in">lt</span>(A[j], A[lowindex]))</span><br><span class="line">        lowindex = j; <span class="comment">// Put it in place</span></span><br><span class="line">    <span class="built_in">swap</span>(A, i, lowindex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较操作的次数最好，最坏，平均都是$ \Omega(N^{2})$<br>交换操作的最少次数</p>
<ul>
<li>最好情况为 0 次</li>
<li>最坏情况是 n-1 次</li>
<li>平均情况是$\Omega(N)$</li>
</ul>
<h3 id="7-2-插入排序"><a href="#7-2-插入排序" class="headerlink" title="7.2 插入排序"></a>7.2 插入排序</h3><p>插入排序利用了已知位置 0 到位置 p-1 升的元素已经处于拍过序的状态的事实<br><strong>插入排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable &gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">( vector&lt;Comparable&gt; &amp; a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> p=<span class="number">1</span> ; p&lt;a.<span class="built_in">size</span>(); ++p )&#123;</span><br><span class="line">        Comparable tmp = std::<span class="built_in">move</span>( a[p] );</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=p; j&gt;<span class="number">0</span> &amp;&amp; tmp &lt; a[j<span class="number">-1</span>]; --j ) a[j]=std::<span class="built_in">move</span>( a[ j<span class="number">-1</span> ]);</span><br><span class="line">        a[ j ] = std::<span class="built_in">move</span>( tmp );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Insertion sort</span></span><br><span class="line"><span class="comment">* Each record is inserted in turn at the correct position</span></span><br><span class="line"><span class="comment">* within a sorted list composed of those records already</span></span><br><span class="line"><span class="comment">* processed</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(E A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) <span class="comment">//insert i’th record</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i; (j&gt;<span class="number">0</span>) &amp;&amp; (Comp::<span class="built_in">prior</span>(A[j], A[j<span class="number">-1</span>])); j--)</span><br><span class="line">    <span class="comment">// A[ j ] &lt; A[ j-1 ]，从 i 开始进行比较</span></span><br><span class="line">      <span class="built_in">swap</span>(A, j, j<span class="number">-1</span>);<span class="comment">// A[j] = A[j-1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入排序的性质"><a href="#插入排序的性质" class="headerlink" title="插入排序的性质"></a>插入排序的性质</h4><p><strong>插入排序是原地排序并且是稳定的</strong><br>插入排序的平均运行时间是 $O(N^{2})$<br>但如果输入数据已经预先排序，那么运行时间为 $O(N)$<br>最坏运行时间为$\Omega(N^{2})$，最好运行时间是$\Omega(N)$<br><strong>交换操作次数</strong>：</p>
<ul>
<li>最好情形为 0 次</li>
<li>平均以及最坏情况都是$\Omega(N^{2})$</li>
</ul>
<h3 id="7-3-一些简单排序算法的下界"><a href="#7-3-一些简单排序算法的下界" class="headerlink" title="7.3 一些简单排序算法的下界"></a>7.3 一些简单排序算法的下界</h3><h4 id="定理-7-1-N-个互异元素的数组的平均逆序数是-N-N-1-4"><a href="#定理-7-1-N-个互异元素的数组的平均逆序数是-N-N-1-4" class="headerlink" title="定理 7.1  N 个互异元素的数组的平均逆序数是 $N(N-1)&#x2F;4$"></a>定理 7.1  N 个互异元素的数组的平均逆序数是 $N(N-1)&#x2F;4$</h4><p>这个定理提供了任何只交换相邻元素的排序算法的一个很强的下界</p>
<h4 id="定理-7-2-通过交换相邻元素进行排序的任何算法平均都需要-Omega-N-2-时间"><a href="#定理-7-2-通过交换相邻元素进行排序的任何算法平均都需要-Omega-N-2-时间" class="headerlink" title="定理 7.2.通过交换相邻元素进行排序的任何算法平均都需要$\Omega(N^{2})$时间"></a>定理 7.2.通过交换相邻元素进行排序的任何算法平均都需要$\Omega(N^{2})$时间</h4><p>为了让一个排序算法以压二次时间运行，必须执行一些比较，特别是要堆相距较远的元素进行交换</p>
<h3 id="7-4-希尔排序-diminishing-increment-sort（缩减增量排序）"><a href="#7-4-希尔排序-diminishing-increment-sort（缩减增量排序）" class="headerlink" title="7.4 希尔排序 diminishing increment sort（缩减增量排序）"></a>7.4 希尔排序 diminishing increment sort（缩减增量排序）</h3><p><strong>亚二次时间界</strong><br>增量序列：$h_{1},h_{2},h_{3},…$<br>只要$h_{1}&#x3D;1$，任何增量序列都是可行的<br>在使用增量 $h_{k}$的一趟排序之后，对于每一个 $i 都有 a[i]\leq a[i+h_{k}]$<br>所有相隔$h_{k}$的元素都被排序，称文件是**$h_{k}-sorted$**的<br><strong>一个$h_{k}-sorted$的文件（此后将是$h_{k-1}-sorted$）保持其$h_{k}$排序性</strong><br>$h_{k}排序的的一般策略是对于$h_{k},h_{k}+1,..,N-1 中的每一个位置 i，把其上的元素放到 i,i-h_{k},i-2h_{k},..$中的正确位置上<br><strong>希尔增量</strong>：$h_{t}&#x3D;\lfloor N&#x2F;2 \rfloor 和 h_{k}&#x3D;\lfloor h_{k+1}&#x2F;2\rfloor$<br><strong>使用希尔增量的希尔排序例程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">( vector&lt;Comparable&gt; &amp; a )</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> gap = a.<span class="built_in">size</span>() / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span> )</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> i=gap; i &lt; a.<span class="built_in">size</span>(); ++i )&#123;</span><br><span class="line">            Comparable tmp = std::<span class="built_in">move</span>( a[ i ] );</span><br><span class="line">            <span class="type">int</span> j=i;</span><br><span class="line">            <span class="keyword">for</span>( ; j&gt;=gap &amp;&amp; tmp &lt; a[ j-gap ]; j -= gap )</span><br><span class="line">                a[ j ] = std::<span class="built_in">move</span>( a[ j- gap ] );</span><br><span class="line">           a[ j ] = std::<span class="built_in">move</span> ( tmp );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>希尔排序的修改版</strong><br>就是对于差一个 gap 的位置上的一系列元素进行插入排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modified version of Insertion Sort </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort2</span><span class="params">(E A[], <span class="type">int</span> n, <span class="type">int</span> incr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=incr; i&lt;n; i+=incr)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=i; (j&gt;=incr) &amp;&amp; (Comp::<span class="built_in">prior</span>(A[j], A[j-incr]));        </span><br><span class="line">            j-=incr)</span><br><span class="line">      <span class="built_in">swap</span>(A, j, j-incr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shellsort</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(E A[], <span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=n/<span class="number">2</span>; i&gt;<span class="number">2</span>; i/=<span class="number">2</span>) <span class="comment">//For each increment</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) <span class="comment">//Sort each sublist</span></span><br><span class="line">      <span class="built_in">inssort2</span>&lt;E,Comp&gt;(&amp;A[j], n-j, i);</span><br><span class="line">  <span class="comment">//Normal insertion sort</span></span><br><span class="line">  <span class="built_in">inssort2</span>&lt;E,Comp&gt;(A, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定理-7-3-使用希尔增量时希尔排序的最坏情形运行时间为-Omega-N-2"><a href="#定理-7-3-使用希尔增量时希尔排序的最坏情形运行时间为-Omega-N-2" class="headerlink" title="定理 7.3 使用希尔增量时希尔排序的最坏情形运行时间为$\Omega(N^{2})$"></a>定理 7.3 使用希尔增量时希尔排序的最坏情形运行时间为$\Omega(N^{2})$</h4><h4 id="Hibbard-增量序列：1，3，7，…，-2-k-1"><a href="#Hibbard-增量序列：1，3，7，…，-2-k-1" class="headerlink" title="Hibbard 增量序列：1，3，7，…，$2^{k}-1$"></a><strong>Hibbard 增量序列：1，3，7，…，$2^{k}-1$</strong></h4><p>相邻的增量之间没有公因子</p>
<h4 id="使用-Hibbard-增量的希尔排序的最坏情形运行时间是-Omega-N-2"><a href="#使用-Hibbard-增量的希尔排序的最坏情形运行时间是-Omega-N-2" class="headerlink" title="使用 Hibbard 增量的希尔排序的最坏情形运行时间是$\Omega(N^{2})$"></a>使用 Hibbard 增量的希尔排序的最坏情形运行时间是$\Omega(N^{2})$</h4><p>更好的增量序列是 <strong>Sedgewick’ s incerment</strong>(best in practice)</p>
<ul>
<li>1，5，19，41，109，…，（$9 * 4^{i} - 9 * 2^{i} + 1 or 4^{i} - 3 * 2^{i} + 1$）</li>
</ul>
<h3 id="7-5-堆排序-heapsort"><a href="#7-5-堆排序-heapsort" class="headerlink" title="7.5 堆排序 heapsort"></a>7.5 堆排序 heapsort</h3><p><strong>运行时间是 $O(NlogN)$</strong><br>每次 deleteMin 之后堆会减少一个位置，所以位于堆中最后的单元可以用来存放刚刚删去的元素<br><strong>堆排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable &gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">( vector&lt;Comparable&gt; &amp; a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = a.<span class="built_in">size</span>( ) / <span class="number">2</span> - <span class="number">1</span>; i&gt;=<span class="number">0</span> ; --i ) <span class="comment">// buildHeap</span></span><br><span class="line">        <span class="built_in">percDown</span>( a, i, a.<span class="built_in">size</span>( ) );</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> j = a.<span class="built_in">size</span>( ) - <span class="number">1</span>; j&gt;<span class="number">0</span> ; --j ) <span class="comment">// deleteMax</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::<span class="built_in">swap</span> ( a[ <span class="number">0</span> ], a[ j ] );</span><br><span class="line">        <span class="built_in">percDown</span>( a, <span class="number">0</span>, j ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="堆排序的性质"><a href="#堆排序的性质" class="headerlink" title="堆排序的性质"></a>堆排序的性质</h5><p>平均运行时间是 $O(NlogN)$，最坏运行情况是$\Omega(NlogN)$<br>堆排序是原地排序但是并不稳定，因为在上滤的过程中有可能会导致相同元素之间的相对位置发生变化</p>
<h3 id="7-6-归并排序"><a href="#7-6-归并排序" class="headerlink" title="7.6 归并排序"></a>7.6 归并排序</h3><p><strong>最坏时间情形为 $O(NlogN)$</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*进行递归调用的内部方法，*a为Comparable项的数组.</span></span><br><span class="line"><span class="comment">*tmpArray 为放置归并结果的数组.</span></span><br><span class="line"><span class="comment">*left 为子数组最左元素的下标。</span></span><br><span class="line"><span class="comment">*right 为子数组最右元素的下标.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;Comparable&gt; &amp; a,</span></span></span><br><span class="line"><span class="params"><span class="function">    vector&lt;Comparable&gt; &amp; tmpArray, <span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( left &lt; right)&#123;</span><br><span class="line">    <span class="type">int</span> center = ( left +right )/ <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>( a,tmpArray,left, center );</span><br><span class="line">    <span class="built_in">mergeSort</span>( a,tmpArray, center + <span class="number">1</span>, right ); </span><br><span class="line">    <span class="built_in">merge</span>( a,tmpArray,left,center + <span class="number">1</span>, right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*合并子数组已排序两半部分的内部方法.</span></span><br><span class="line"><span class="comment">*a为Comparable项的数组.</span></span><br><span class="line"><span class="comment">*tmpArray 为放置归并结果的数组，</span></span><br><span class="line"><span class="comment">* leftPos 为子数组最左元素的下标，</span></span><br><span class="line"><span class="comment">* rightPos 为后半部分起点的下标，</span></span><br><span class="line"><span class="comment">* rightEnd 为子数组最右元素的下标。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">( vector&lt;Comparab1e&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> leftPos, <span class="type">int</span> rightPos, <span class="type">int</span> rightEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> leftEnd = rightPos <span class="number">-1</span>;  <span class="comment">//左半个数组的终点</span></span><br><span class="line">    <span class="type">int</span> tmpPos = leftPos; <span class="comment">//复制到 tmpArray 的起点，从 leftPos 开始</span></span><br><span class="line">    <span class="type">int</span> numElements = rightEnd - leftPos + <span class="number">1</span>; <span class="comment">//数组元素的个数</span></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd )</span><br><span class="line">    <span class="keyword">if</span>( a[ leftPos ]&lt;= a[ rightPos ])</span><br><span class="line">        tmpArray[ tmpPos++]= std::<span class="built_in">move</span>( a[ leftPos++]); </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tmpArray[ tmpPos++]= std::<span class="built_in">move</span>( a[ rightPos++]);</span><br><span class="line">    <span class="keyword">while</span>( leftPos &lt;= leftEnd ) <span class="comment">// 复制前半部分的剩余元素</span></span><br><span class="line">        tmpArray[ tmpPos++ ]= std::<span class="built_in">move</span>( a[ leftPos++]);</span><br><span class="line">    <span class="keyword">while</span>( rightPos &lt;= rightEnd)<span class="comment">//复制后半部分的剩余元素</span></span><br><span class="line">        tmpArray[ tmpPos++ ]= std::<span class="built_in">move</span>( a[ rightPos++]);</span><br><span class="line">    <span class="comment">//将tmpArray复制回原数组a</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i&lt; numElements;++i,--rightEnd )</span><br><span class="line">        a[ rightEnd ]= std::<span class="built_in">move</span>( tmpArray[ rightEnd ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 归并排序的另一种实现方式</span></span><br><span class="line"><span class="comment">// 对于小数组使用插入排序，当两个子数组变为空的时候不需要进行额外的检查</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergesort</span><span class="params">(E A[], E temp[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((right-left) &lt;= THRESHOLD) &#123; <span class="comment">//small list</span></span><br><span class="line">    <span class="built_in">insertionsort</span>&lt;E,Comp&gt;(&amp;A[left], right-left<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> i, j, k, mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (left == right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E, Comp&gt;(A, temp, left, mid);</span><br><span class="line">  <span class="built_in">mergesort</span>&lt;E, Comp&gt;(A, temp, mid<span class="number">+1</span>, right);</span><br><span class="line">  <span class="comment">//Do the merge operation. First copy two halves to temp</span></span><br><span class="line">  <span class="keyword">for</span> (i=mid; i&gt;=left; i--) temp[i] = A[i];</span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=right-mid; j++) temp[right-j<span class="number">+1</span>] = A[j+mid]; <span class="comment">// reverse order</span></span><br><span class="line">  <span class="comment">//Merge sublists back to A</span></span><br><span class="line">  <span class="keyword">for</span> (i=left, j=right, k=left; k&lt;=right; k++)</span><br><span class="line">    <span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(temp[i], temp[j])) A[k] = temp[i++];</span><br><span class="line">    <span class="keyword">else</span> A[k] = temp[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="归并排序的分析"><a href="#归并排序的分析" class="headerlink" title="归并排序的分析"></a>归并排序的分析</h5><p>时间复杂度为 $O(NlogN)$<br>需要$O(N)$的额外空间<br>归并排序是稳定的</p>
<h3 id="7-7-快速排序"><a href="#7-7-快速排序" class="headerlink" title="7.7 快速排序"></a>7.7 快速排序</h3><p><strong>平均运行时间 $O(NlogN)$</strong><br>快速排序算法由下列简单的 4 步组成</p>
<ol>
<li>如果 S 中元素个数为 0 或 1，则返回</li>
<li>取 S 中任一元素 v，称之为 pivot</li>
<li>将 S - {v}（即 S 中其余元素）划分成两个不相交的集合：$S_{1}$&#x3D;{$x \in S - {v} | x\leq v$},$S_{2}$&#x3D;{$ x \in S - {v} | x\geq v$}</li>
<li>返回{quicksort($S_{1}$),后跟 v，继而再 quicksort($S_{2}$)}</li>
</ol>
<p>#####<strong>三数中值分割法（Median-of-Three Partitioning）</strong><br>使用左端，右端，中心位置上的三个元素的中值作为枢纽元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  返回 left，center，right 三项的中值，将他们排序并隐匿枢纽元</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;</span><br><span class="line"><span class="function"><span class="type">const</span> Comparable &amp; <span class="title">median3</span><span class="params">( vector&lt;Comparable&gt; &amp; a,<span class="type">int</span> left,<span class="type">int</span> right )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( a[ center ] ‹ a[ left ])</span><br><span class="line">        std:: <span class="built_in">swap</span> ( a[ left ], a[ center ] );</span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; al left ] )</span><br><span class="line">        std:: <span class="built_in">swap</span> ( a[ left ], a[ right] );</span><br><span class="line">    <span class="keyword">if</span> a[right] &lt; a[ center ] )</span><br><span class="line">        std:: <span class="built_in">swap</span> ( a[ center ], a[ right ] );</span><br><span class="line">    <span class="comment">// 将枢纽元置于 right-1处</span></span><br><span class="line">    std:: <span class="built_in">swap</span> ( a[ center ], al right - <span class="number">1</span>] );</span><br><span class="line">     <span class="keyword">return</span> a[ right - <span class="number">1</span> ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 进行递归调用的内部快速排序方法，</span></span><br><span class="line"><span class="comment">* 使用三数中值分割法，以及截止范围是10的截止技术.</span></span><br><span class="line"><span class="comment">* a 是Comparable 项的数组.</span></span><br><span class="line"><span class="comment">* left 为子数组最左元素的下标。</span></span><br><span class="line"><span class="comment">* right 为子数组最右元素的下标.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">template &lt;typename Comparable&gt;</span></span><br><span class="line"><span class="comment">void quicksort( vector&lt;Comparable&gt; &amp; a,int left,int right)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if( left + 10 &lt;= right )</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        const Comparable &amp; pivot = midian3( a, left, right )</span></span><br><span class="line"><span class="comment">        //开始分割</span></span><br><span class="line"><span class="comment">       int i = left, j = right -1;</span></span><br><span class="line"><span class="comment">        for( ; ; )</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //因为 left，right，center 三者已经排序，所以 left 处的元素一定小于 等于pivot，right 处元素一定大于等于 pivot，而 right-1 存放的是 pivot，所以 j 从 right-1 处开始，++i，--j 直接从 1 和 right-2 开始进行比较</span></span><br><span class="line"><span class="comment">            while( a[ ++i ] &lt; pivot )&#123;&#125;</span></span><br><span class="line"><span class="comment">            while( pivot &lt; a[ --j ] )&#123;&#125;</span></span><br><span class="line"><span class="comment">            if( i &lt; j )</span></span><br><span class="line"><span class="comment">                std::swap( a[ i ],a[ j ] );</span></span><br><span class="line"><span class="comment">           else    </span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //i 最后指向第一个大于等于 pivot 的位置，因为 pivot 在 right-1 所以必须要找到偏大一点的分界点而不是 j 所代表的偏小的分界点</span></span><br><span class="line"><span class="comment">        std::swap( a[ i ],a[ right - 1 ] );//恢复枢纽元</span></span><br><span class="line"><span class="comment">        quicksort( a, left, i-1 );</span></span><br><span class="line"><span class="comment">        quicksort( a, i + 1, right );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">        insertionSort( a, left, right );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">// 另一种实现方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;typename E, typename Comp&gt;</span></span><br><span class="line"><span class="comment">int partition(E A[], int l, int r, E&amp; pivot) &#123;</span></span><br><span class="line"><span class="comment">  do &#123;</span></span><br><span class="line"><span class="comment">     //Move the bounds inward until they meet</span></span><br><span class="line"><span class="comment">     //Move l right and r left</span></span><br><span class="line"><span class="comment">     while (Comp::prior(A[++l], pivot));</span></span><br><span class="line"><span class="comment">     while ((l&lt;r) &amp;&amp; Comp::prior(A[--r],pivot));</span></span><br><span class="line"><span class="comment">     // Swap out-of-place values</span></span><br><span class="line"><span class="comment">     swap(A, l, r); </span></span><br><span class="line"><span class="comment">  &#125; while (l &lt; r); // Stop when they cross</span></span><br><span class="line"><span class="comment">  swap(A, l, r);   // Reverse last swap[最后一次交换是多余的]</span></span><br><span class="line"><span class="comment">  return l; //Return 1st position in right part</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>
<h5 id="快速排序的性质"><a href="#快速排序的性质" class="headerlink" title="快速排序的性质"></a>快速排序的性质</h5><p>最坏情形运行时间为 $O(N^{2})$<br>最好情形运行时间 $\Omega(NlogN)$<br>平均情形运行时间$O(NlogN)$<br><strong>不是稳定的算法</strong><br><strong>虽然是原地排序但是由于递归所以需要$O(logN)$的额外空间</strong></p>
<h4 id="7-7-6-选择问题的线性期望时间算法"><a href="#7-7-6-选择问题的线性期望时间算法" class="headerlink" title="7.7.6 选择问题的线性期望时间算法"></a>7.7.6 选择问题的线性期望时间算法</h4><p><strong>快速选择算法</strong></p>
<ol>
<li>如果｜S｜&#x3D;1，那么 k&#x3D;1 并且将 S 中的元素作为答案返回，如果正在使用小数组的截止方法且｜S｜$ \leq CUTOFF$，则将 S 排序并且返回第 k 个元素</li>
<li>选取一个枢纽元$v \in S$</li>
<li>将集合$S-{v}$  分割成 $S_{1}和 S_{2}$，过程就像在快速排序中所做的一样</li>
<li>如果 $k \leq | S_{1} |$，那么第 k 个最小元必然在$S_{1}$中，所以返回 quickselect($S_{1}$,k)。如果 k&#x3D;1+ | $S_{1}$ |，那么枢纽元就是第 k 个最小元，将其作为答案返回。否则这第 k 个最小元就在 $S_{2}$中，它是$S_{2}$中的第（k- |       $S_{1}$ |-1 ）的最小元，返回 quickselect($S_{2}$,k- | $S_{1}$ | - 1)。<br><strong>但是快速选择的平均运行时间为 $O(N)$</strong></li>
</ol>
<h3 id="7-8-桶排序"><a href="#7-8-桶排序" class="headerlink" title="7.8 桶排序"></a>7.8 桶排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* Bucket Sort</span></span><br><span class="line"><span class="comment">* Allow for duplicate values among keys</span></span><br><span class="line"><span class="comment">* Allow for a set of N records falling in a range larger </span></span><br><span class="line"><span class="comment">* than N ([0,MaxKeyValue-1])</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">class</span> <span class="title class_">getKey</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketsort</span><span class="params">(E A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; B[MaxKeyValue]; <span class="comment">//An array of linked lists</span></span><br><span class="line">  E item;</span><br><span class="line">  <span class="comment">//assign records to bins </span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="comment">//All records with key value i are placed in bin B[i]</span></span><br><span class="line">    B[getKey::<span class="built_in">key</span>(A[i])].<span class="built_in">append</span>(getKey::<span class="built_in">key</span>(A[i]));</span><br><span class="line">  <span class="comment">//process MaxKeyValue bins to output records</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MaxKeyValue; i++)</span><br><span class="line">    <span class="keyword">for</span> (B[i].<span class="built_in">setStart</span>(); B[i].<span class="built_in">getValue</span>(item); B[i].<span class="built_in">next</span>())</span><br><span class="line">      <span class="built_in">output</span>(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>桶排序的时间消耗包括：</p>
<ul>
<li>$\Omega(N)$的时间将所有的 N 条记录放入桶中</li>
<li>扫描$MaxKeyValue$个桶去输出 N 个记录<br>如果 $MaxKeyValue$是$\Omega(N^{2})$的，那么总时间消耗将是$\Omega(N^{2})$的<br><strong>有一个限制是桶排序只对一个有限制的 key 的范围有效</strong><br>桶排序也可以对于一个 key 的最右边最低有效位开始对于每一个数位进行排序，直到对于最后一个最高有效位进行排序，最后会产生一个排序了的列表<br>这样的时间复杂度为$\Omega(N)$</li>
</ul>
<h3 id="7-9-基数排序-radix-sort"><a href="#7-9-基数排序-radix-sort" class="headerlink" title="7.9 基数排序 radix sort"></a>7.9 基数排序 radix sort</h3><p>根据 radix 或者 base 对于 keyValue 的计算结果将数字放入桶中<br>根据 key 的数位从最右边的数位到最左边数位的顺序将记录安排到桶中<br>$b 为 base,r 为在 base 为 b 的情况下最大数字的位数$<br>一共会进行 r 轮，keys 被按顺序从桶中取出并且再次被放入桶中<br><strong>总的运行时间是$O(r(N+b))$</strong><br><strong>Radix Sort</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Radix sort an array of Strings.</span></span><br><span class="line"><span class="comment">* Assume all characters are ASCII, residing in the first 256 </span></span><br><span class="line"><span class="comment">* positions of the Unicode character set.</span></span><br><span class="line"><span class="comment">* Assume all have same length(stringLen).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSortA</span><span class="params">( vector&lt;string&gt; &amp; arr, <span class="type">int</span> stringLen )</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUCKETS = <span class="number">256</span>;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">buckets</span>( BUCKETS );</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> pos = stringLen - <span class="number">1</span>; pos &gt;= <span class="number">0</span>; --pos )&#123;</span><br><span class="line">        <span class="keyword">for</span>( string &amp; s : arr )</span><br><span class="line">            <span class="comment">//Adds s at the end of the buckets[ s[ pos ] ]</span></span><br><span class="line">           buckets[ s[ pos ] ].<span class="built_in">push_back</span>( std::<span class="built_in">move</span>( s ) );</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> &amp; thisBucket : buckets )&#123;</span><br><span class="line">            <span class="keyword">for</span>( string &amp; s : thisBucket )</span><br><span class="line">                 arr[ idx++ ] = std::<span class="built_in">move</span>( s );</span><br><span class="line">            thisBucket.<span class="built_in">clear</span>( );</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Counting Radix Sort</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Counting radix sort</span></span><br><span class="line"><span class="comment">* B[] is array for buckets</span></span><br><span class="line"><span class="comment">* cnt[i] stores numbers of records in bucket[i]</span></span><br><span class="line"><span class="comment">* b is numbers of buckets(base), r is number of passes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">typename</span> getKey&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix</span><span class="params">(E A[], E B[], <span class="type">int</span> n, <span class="type">int</span> r, <span class="type">int</span> b, <span class="type">int</span> cnt[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>, btoi=<span class="number">1</span>; i&lt;r; i++, btoi*=b) &#123;<span class="comment">//for r digits</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;b; j++) cnt[j] = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//Count # of records for each buckets on this pass</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n; j++) cnt[(getKey::<span class="built_in">key</span>(A[j])/btoi)%b]++;</span><br><span class="line">    <span class="comment">//Index B: cnt[j] will be index for last slot of bucket j.</span></span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;b; j++) cnt[j] += cnt[j<span class="number">-1</span>] ;</span><br><span class="line">    <span class="comment">/*Put records into buckets, from bottom of each bucket.*/</span></span><br><span class="line">    <span class="keyword">for</span> (j=n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) </span><br><span class="line">      B[--cnt[(getKey::<span class="built_in">key</span>(A[j])/btoi)%b]] = A[j];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) A[j] = B[j]; <span class="comment">//Copy B back to A.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Radix-Sort-的性质"><a href="#Radix-Sort-的性质" class="headerlink" title="Radix Sort 的性质"></a>Radix Sort 的性质</h6><p>总的时间复杂度是 <strong>$\Omega (r(N+b))$</strong><br>摊还时间复杂度为$\Omega(NlogN)$<br>基数排序是稳定的，但不是原地排序</p>
<h3 id="7-10-排序问题的下界"><a href="#7-10-排序问题的下界" class="headerlink" title="7.10 排序问题的下界"></a>7.10 排序问题的下界</h3><ul>
<li>任何排序问题都不可能被任何算法以小于$\Omega(N)$的时间解决</li>
<li>任何基于比较的算法在最坏情况下都不可能优于$\Omega(NlogN)$<br>决策树是一棵二叉树，可以模拟任何作出二项选择的过程<br>决策树中最深节点的深度对应算法的最坏情况</li>
</ul>
<p><strong>一棵有$L$个叶子节点的二叉树至少有 $\lceil logL \rceil$的深度</strong><br>所以任何基于比较的算法最坏情况都是$\lceil log(N!) \rceil&#x3D;\Omega(NlogN)$<br>因为 N 个数字的排序有 N！种可能</p>
<h5 id="选择问题的决策树下界"><a href="#选择问题的决策树下界" class="headerlink" title="选择问题的决策树下界"></a>选择问题的决策树下界</h5><h6 id="找到第-k-小的数字需要-N-k-lceil-log-binom-N-k-1-rceil"><a href="#找到第-k-小的数字需要-N-k-lceil-log-binom-N-k-1-rceil" class="headerlink" title="找到第 k 小的数字需要 N-k+$\lceil log \binom{N}{k-1} \rceil$"></a><strong>找到第 k 小的数字需要 N-k+$\lceil log \binom{N}{k-1} \rceil$</strong></h6><h6 id="找到第-k-小元素的决策树至少有-binom-N-k-1-2-N-k-个树叶"><a href="#找到第-k-小元素的决策树至少有-binom-N-k-1-2-N-k-个树叶" class="headerlink" title="找到第 k 小元素的决策树至少有 $\binom{N}{k-1}2^{N-k}$个树叶"></a><strong>找到第 k 小元素的决策树至少有 $\binom{N}{k-1}2^{N-k}$个树叶</strong></h6><p>找到最小元素至少需要 N-1次比较</p>
<h3 id="7-11-外部排序-External-Sorting"><a href="#7-11-外部排序-External-Sorting" class="headerlink" title="7.11 外部排序 External Sorting"></a>7.11 外部排序 External Sorting</h3><p>用于处理很大的输入，因为输入太大为无法被放入内存中</p>
<ul>
<li>记录被储存在磁带中，只能被顺序的进行访问</li>
<li>假设算法有至少三条磁带用于执行</li>
<li>假设内存最多同时可以存储并且排序 M 条记录<br>算法一共需要$\lceil log(N&#x2F;M) \rceil$轮<br>如果使用 k-way merge 也就是在 k 条记录中选取最小值那么这个数字可以变为$\lceil log_{k}(N&#x2F;M) \rceil$</li>
</ul>
<h5 id="Replacement-selection"><a href="#Replacement-selection" class="headerlink" title="Replacement selection"></a>Replacement selection</h5><p>replacement selection 可以平均让每一轮的长度为 2M<br>这是一种堆排序的变式</p>
<ul>
<li>读取 M 条数据到内存中，设置 last&#x3D;m-1（指向堆数组中最后一个元素）</li>
<li>将 M 个数据放入最小堆</li>
<li>重复以下步骤直到堆为空</li>
</ul>
<ol>
<li>deleteMin 并且将最小值写到输出磁带上</li>
<li>让 R 为下一个输入磁带中读取的记录，如果 R 大于刚才的输出就将 R 放在 root 处，否则就用 LAST 处的数据放在 root 处并且将 R 放在 LAST 位置，将 LAST 设置为 LAST-1（堆的大小减少 1）</li>
<li>重新排序堆（保持堆序）</li>
</ol>
<h2 id="第-8-章-不相交集类（并查集）"><a href="#第-8-章-不相交集类（并查集）" class="headerlink" title="第 8 章 不相交集类（并查集）"></a>第 8 章 不相交集类（并查集）</h2><p>并查集类是一个在线的问题，因为 find 解决的的合并问题是在合并操作之间进行的</p>
<p><strong>构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DisjSets::<span class="built_in">DisjSets</span>( <span class="type">int</span> numElements ) : s&#123; numElements, <span class="number">-1</span> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="任意合并：使第二棵树成为第一棵树的子树"><a href="#任意合并：使第二棵树成为第一棵树的子树" class="headerlink" title="任意合并：使第二棵树成为第一棵树的子树"></a>任意合并：使第二棵树成为第一棵树的子树</h4><p>普通的任意合并对于一系列操作的时间复杂度可能达到$\Omega(MN)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjSets::unionSets</span><span class="params">( <span class="type">int</span> root1, <span class="type">int</span> root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[ root2 ] = root1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Perform a find.</span></span><br><span class="line"><span class="comment">  * Error checks omitted again for simplicity.</span></span><br><span class="line"><span class="comment">  * Return the set containing x.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjSets::find</span><span class="params">( <span class="type">int</span> x )</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ x ] &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>( s[ x ] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="union-by-size-将大小小的树合并到大小较大的树上"><a href="#union-by-size-将大小小的树合并到大小较大的树上" class="headerlink" title="union by size 将大小小的树合并到大小较大的树上"></a>union by size 将<strong>大小</strong>小的树合并到<strong>大小</strong>较大的树上</h4><p>如果所有 union 都以按照大小合并进行，那么可以保证任何节点的深度都不会超过 $O(logN)$<br>对于按大小合并的算法，find 的运行时间是 $O(logN)$<br>由于实际上只使用一个数组，所以可以让每个座位数组元素的根包含它的树大小的负值，这样初始时树的数组表示就都是-1。<br>当执行一次 union 的时候，要检查树的大小并更新为两棵旧的树的和，如果使用按大小求并则 连续 M 次 union 运算需要$O(M)$平均时间</p>
<h4 id="union-by-height-rank-使得高度较小的树成为高度较高的树的子树"><a href="#union-by-height-rank-使得高度较小的树成为高度较高的树的子树" class="headerlink" title="union by height&#x2F;rank 使得高度较小的树成为高度较高的树的子树"></a>union by height&#x2F;rank 使得高度较小的树成为高度较高的树的子树</h4><p>同样保证所有的树的深度最多就是$O(logN)$<br>这是一种平缓的算法，因为只有两棵相等深度的树求并的时候树的高度才会增加<br>由于开始的时候高度是 0 不是负数，所以我们实际上存储<strong>高度的负值并且减去一个附加的 1</strong><br><strong>union by height&#x2F;rank</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjSets::unionSets</span><span class="params">( <span class="type">int</span> root1, <span class="type">int</span> root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ root2 ] &lt; s[ root1 ] )</span><br><span class="line">        s[ root1 ] = root2;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( s[ root1 ] == s[ root2 ] )</span><br><span class="line">            --s[ root1 ];</span><br><span class="line">        s[ root2 ] = root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>路径压缩在一次 find 操作期间执行，而与用来执行 union 的方法无关<br>假设 find（x），路径压缩的效果就是从 x 到根的路径上的每一个节点都使他的父节点变成根<br><img src="/blog/img/sjjg-badcase.jpg"><br>执行 find（14）后产生的树<br><img src="/blog/img/sjjg8-15.jpg"><br><strong>路径压缩</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjSets::find</span><span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( s[ x ] &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> s[ x ] = <span class="built_in">find</span>( s[ x ] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按秩合并和路径压缩的最坏情形都是$\Omega(M\alpha(M,N)),其中\alpha(M,N)是一个增长极为缓慢的函数，最大也只能达到 5$</p>
<h2 id="第-9-章-图论算法"><a href="#第-9-章-图论算法" class="headerlink" title="第 9 章 图论算法"></a>第 9 章 图论算法</h2><h3 id="9-1-定义"><a href="#9-1-定义" class="headerlink" title="9.1 定义"></a>9.1 定义</h3><p>简单路径：其上的所有顶点互异，但第一个顶点和最后一个顶点可能相同<br>有向无环图简称为 DAG</p>
<ul>
<li>强连通：有向图中从每一个顶点到每一个其他节点都存在一条路径</li>
<li>弱连通：有向图不联通，但是其基础图是连通的</li>
<li>完全图：其每一对顶点之间都存在一条边</li>
</ul>
<h3 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h3><p>先找出任意一个入度为 0 的顶点，然后显示出该顶点，并将它和它的边一起从图中删除。对其余部分继续应用这样的方法。<br><strong>拓扑排序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void Graph::topsort( )</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;Vertex&gt; q;</span><br><span class="line">    int counter = 0;</span><br><span class="line">    </span><br><span class="line">    q.makeEmpty( );</span><br><span class="line">    for each Vertex v</span><br><span class="line">        if( v.indegree == 0 )</span><br><span class="line">            q.enqueue( v );</span><br><span class="line">    while( !q.isEmpty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex v = q.dequeue( );</span><br><span class="line">        v.topNum = ++counter //分配下一个拓扑编号</span><br><span class="line"></span><br><span class="line">        for each Veertex w adjacent to v</span><br><span class="line">            if( --w.indegree == 0 )</span><br><span class="line">                q.enqueue( w );</span><br><span class="line">    &#125;</span><br><span class="line">    if( counter != NUM_VERTICES )</span><br><span class="line">        throw CycleFoundException&#123; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算入度</span><br><span class="line">for each Vertex v</span><br><span class="line">    for each Vertex w adjacent to v</span><br><span class="line">        w.indegree++;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-最短路径算法"><a href="#9-3-最短路径算法" class="headerlink" title="9.3 最短路径算法"></a>9.3 最短路径算法</h3><p>当出现<strong>负值圈</strong>的时候，最短路径问题就是不确定的</p>
<h5 id="无权最短路径（BFS）"><a href="#无权最短路径（BFS）" class="headerlink" title="无权最短路径（BFS）"></a>无权最短路径（BFS）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> void Graph::unweighted( Vertex s )</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;VErtex&gt; q;</span><br><span class="line">    for each Vertex v</span><br><span class="line">        v.dist = INFINITY;</span><br><span class="line">    </span><br><span class="line">    s.dist = 0;//源点</span><br><span class="line">    s.enqueue( s );</span><br><span class="line"></span><br><span class="line">    while( !q.isEmpty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex v = q.dequeue( );</span><br><span class="line">        for each Vertex w adjacent to v</span><br><span class="line">            if( w.dist == INFINITY )</span><br><span class="line">            &#123;</span><br><span class="line">                w.dist = v.dist + 1;</span><br><span class="line">                w.path = v;</span><br><span class="line">                q.enqueue( w );</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h5><p>在每个阶段，Dijkstra 算法选择一个在所有 unknown 顶点中具有最小的$d_{v}$的顶点，同时声名从 s 到 v 的最短路径是 known 的，阶段的其余部分由 $d_{w}$的更新工作组成。<br>和 bfs 是一样的，如果所有的边都是正权边那么第一次遇到顶点并处理的时候一定得到最小的距离，所以在第二次遇到的时候如果节点已经声明为 known 那么就不做任何修改。<br><strong>Dijkstra</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Grapgh::dijkstra( Vertex s )</span><br><span class="line">&#123;</span><br><span class="line">    for each Vertex v</span><br><span class="line">    &#123;</span><br><span class="line">        v.dist = INFINITY;</span><br><span class="line">        v.known = false;</span><br><span class="line">    &#125;</span><br><span class="line">    s.dist = 0;</span><br><span class="line">    while( ther is an unkonwn distance vertex )</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex v = samllest unknown distance vertex;</span><br><span class="line">        v.known = true;</span><br><span class="line">        for each Vertex w adjacent to v</span><br><span class="line">            if( !w.known )</span><br><span class="line">            &#123;</span><br><span class="line">                DistType cvw = cost of from v to w;</span><br><span class="line">                if( v.dist + cvw &lt; w.dist )</span><br><span class="line">                &#123;</span><br><span class="line">                    decrease( w.dist to v.dist + cvw );</span><br><span class="line">                    w.path = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h4><p>一个图的生成树点集和原来相同，边集是原来边集的子集且是联通的，并且在生成树的边集中没有环</p>
<p>DFS的路径就是一颗生成树</p>
<p><strong>DFS算法也可以用来找联通块</strong></p>
<p><strong>每个联通块都有相同的标号，不同的联通块之间的标号不相同</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Main &#123;</span><br><span class="line">i : integer</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span> M[i] := <span class="number">0</span>;  <span class="comment">//initial label is zero</span></span><br><span class="line">label := <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> M[i] = <span class="number">0</span> then <span class="built_in">DFS</span>(G,M,i,label); <span class="comment">//if i is not labeled</span></span><br><span class="line">  label := label + <span class="number">1</span>;                            <span class="comment">//then call DFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DFS</span>(G[]: node ptr array, M[]: <span class="type">int</span> array, i,label: <span class="type">int</span>) &#123;</span><br><span class="line">  v : node pointer; </span><br><span class="line">  M[i] := label;</span><br><span class="line">  v := G[i];  <span class="comment">// first neighbor //</span></span><br><span class="line">  <span class="keyword">while</span> v != null <span class="keyword">do</span>  <span class="comment">// recursive call (below)</span></span><br><span class="line">    <span class="keyword">if</span> M[v.index] = <span class="number">0</span> then <span class="built_in">DFS</span>(G,M,v.index,label);</span><br><span class="line">    v := v.next;  <span class="comment">// next neighbor //</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度和空间复杂度都是$O(n+m)$</p>
<p><strong>dfs</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph* G, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">PreVisit</span>(G, v);  <span class="comment">// Take some actions</span></span><br><span class="line">  G-&gt;<span class="built_in">setMark</span>(v, VISITED); <span class="comment">//mark v</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">    <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">      <span class="built_in">DFS</span>(G, w);</span><br><span class="line">  <span class="built_in">PostVisit</span>(G, v); <span class="comment">// Take some actions</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>bfs</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G, <span class="type">int</span> start, Queue&lt;<span class="type">int</span>&gt;*Q)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> v, w;</span><br><span class="line">  Q-&gt;<span class="built_in">enqueue</span>(start);        <span class="comment">// Initialize Q</span></span><br><span class="line">  G-&gt;<span class="built_in">setMark</span>(start, VISITED);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>() != <span class="number">0</span>) &#123; <span class="comment">// Process Q</span></span><br><span class="line">    v = Q-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">    <span class="built_in">PreVisit</span>(G, v);   <span class="comment">// Take some actions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">      <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED) &#123;</span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(w, VISITED);</span><br><span class="line">        Q-&gt;<span class="built_in">enqueue</span>(w);</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h4><p>bfs实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Queue-based topological sort</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G, Queue&lt;<span class="type">int</span>&gt;* Q)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> InDgree[G-&gt;<span class="built_in">n</span>()];  <span class="comment">//the size is the number of vertices</span></span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) InDgree[v] = <span class="number">0</span>; <span class="comment">//initialize</span></span><br><span class="line">    <span class="comment">//compute indgree for every vertex</span></span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) <span class="comment">// Process every edge</span></span><br><span class="line">         <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">             InDgree [w]++;   <span class="comment">// Add to w&#x27;s InDgree</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>; v&lt;G-&gt;<span class="built_in">n</span>(); v++) <span class="comment">// Initialize Queue Q</span></span><br><span class="line">         <span class="keyword">if</span> (InDgree[v] == <span class="number">0</span>) <span class="comment">// enqueue v with no prerequisites</span></span><br><span class="line">              Q-&gt;<span class="built_in">enqueue</span>(v);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>() != <span class="number">0</span>) &#123; <span class="comment">//process vertices in Q</span></span><br><span class="line">         v = Q-&gt;<span class="built_in">dequeue</span>();  </span><br><span class="line">         <span class="built_in">printout</span>(v);     <span class="comment">// output v</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w)) &#123;</span><br><span class="line">             InDgree[w]--;    <span class="comment">// One less prerequisite</span></span><br><span class="line">             <span class="keyword">if</span> (InDgree[w] == <span class="number">0</span>) <span class="comment">//vertex v is now free</span></span><br><span class="line">                 Q-&gt;<span class="built_in">enqueue</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>dfs实现</p>
<ul>
<li>当一个节点已经被访问过的时候，什么也不做</li>
<li>当一个递归pop back回原来节点的时候将该节点输出</li>
<li>这个算法<strong>将以逆序输出拓扑排序的结果</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Initialize Mark</span></span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(i, UNVISITED);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Process vertices</span></span><br><span class="line">        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G, i);       <span class="comment">// Call helper</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tophelp</span><span class="params">(Graph* G, <span class="type">int</span> v)</span> </span>&#123; <span class="comment">// Process v</span></span><br><span class="line">    G-&gt;<span class="built_in">setMark</span>(v, VISITED);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G, w);</span><br><span class="line">  <span class="built_in">printout</span>(v);    <span class="comment">// output v</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Shortest-Path-Algorithms"><a href="#Shortest-Path-Algorithms" class="headerlink" title="Shortest-Path Algorithms"></a>Shortest-Path Algorithms</h4><p>无权最短路使用BFS就可以解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Distance[s] := <span class="number">0</span></span><br><span class="line"><span class="built_in">Enqueue</span>(Q,s); </span><br><span class="line"><span class="built_in">Mark</span>(s); <span class="comment">//After a vertex is marked once </span></span><br><span class="line">               <span class="comment">// it won’t be enqueued again</span></span><br><span class="line"><span class="keyword">while</span> queue is <span class="keyword">not</span> empty <span class="keyword">do</span></span><br><span class="line">    X := <span class="built_in">Dequeue</span>(Q);</span><br><span class="line">   <span class="keyword">for</span> each vertex Y adjacent to X <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> Y is unmarked then</span><br><span class="line">           Distance[Y] := Distance[X] + <span class="number">1</span>;</span><br><span class="line">           Previous[Y] := X; <span class="comment">//if we want to record paths</span></span><br><span class="line">           <span class="built_in">Enqueue</span>(Q,Y); </span><br><span class="line">           <span class="built_in">Mark</span>(Y);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Implementation of Dijkstra’s algorithm</span></span><br><span class="line"><span class="comment">//compute shortest path dists from “s”</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G, <span class="type">int</span>* D, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, v, w;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Initialize</span></span><br><span class="line">      D[i] = INFINITY;</span><br><span class="line">  D[s] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) &#123; <span class="comment">//process vertices</span></span><br><span class="line">    <span class="comment">//find the unvisited vertex with min dist</span></span><br><span class="line">    v = <span class="built_in">minVertex</span>(G, D); </span><br><span class="line">    <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>; <span class="comment">//v is unreachable</span></span><br><span class="line"></span><br><span class="line">	  G-&gt;<span class="built_in">setMark</span>(v, VISITED);</span><br><span class="line">    <span class="comment">//update the distance of v’s neighbors</span></span><br><span class="line">    <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w = G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">        <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">		 	<span class="keyword">if</span> (D[w] &gt; (D[v] + G-&gt;<span class="built_in">weight</span>(v, w)))</span><br><span class="line">        		D[w] = D[v] + G-&gt;<span class="built_in">weight</span>(v, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题在于如何实现minVertex函数，找到距离最小的未访问节点</p>
<ol>
<li><p>扫描一遍所有|V|个节点找到最小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minVertex</span><span class="params">(Graph* G, <span class="type">int</span>* D)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i, v = <span class="number">-1</span>; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">//initialize v to some unvisited vertex</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED) &#123; </span><br><span class="line">        v = i; </span><br><span class="line">        <span class="keyword">break</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Now find smallest D value</span></span><br><span class="line">  <span class="keyword">for</span> (i++; i&lt;G-&gt;<span class="built_in">n</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> ((G-&gt;<span class="built_in">getMark</span>(i) == UNVISITED) &amp;&amp; (D[i] &lt; D[v]))</span><br><span class="line">      v = i;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后会导致总的时间复杂度变为$\Omega(|V|^{2})$</p>
</li>
<li><p>将所有未处理过的节点都放入一个优先队列中（小根堆）并且按照距离排序</p>
<p>下一个距离值最小的节点可以在$\Omega(logN)$时间内找到</p>
<p>当每一次对D（x）进行更新之后</p>
<ul>
<li>在堆中删除D（x）并且将新的D（x）重新插入</li>
<li>或者在堆中插入一个更小的新距离值D（x）作为一条新的记录，后面较大的那条记录自然会被忽视，因为距离小的这条记录将会使节点变为<strong>VISITED</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation using the priority queue</span></span><br><span class="line"><span class="comment">// Class for elements in the heap</span></span><br><span class="line">Class DijkElem &#123;</span><br><span class="line">Public:</span><br><span class="line">  <span class="type">int</span> vertex, distance;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">DijkElem</span>() &#123;vertex = <span class="number">-1</span>; distance = <span class="number">-1</span>;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">DijkElem</span>(<span class="type">int</span> v, <span class="type">int</span> d) &#123;vertex = v; distance = d&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Implementation of Dijkstra’s algorithm </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G, <span class="type">int</span>* D, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, v, w;       <span class="comment">// v is current vertex</span></span><br><span class="line">    DijkElem temp;  DijkElem E[G-&gt;<span class="built_in">e</span>()]; <span class="comment">// Heap array  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) <span class="comment">// Initialize</span></span><br><span class="line">       D[i] = INFINITY;</span><br><span class="line">    D[s] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Initialize heap array</span></span><br><span class="line">    temp.distance = <span class="number">0</span>; temp.vertex = s; </span><br><span class="line">    E[<span class="number">0</span>] = temp;     </span><br><span class="line">    <span class="function">heap&lt;DijkElem, DDComp&gt; <span class="title">H</span><span class="params">(E, <span class="number">1</span>, G-&gt;e())</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// get an unvisited vertex with smallest distance</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;G-&gt;<span class="built_in">n</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            <span class="keyword">if</span>(H.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// Nothing to remove</span></span><br><span class="line">            temp = H.<span class="built_in">removefirst</span>(); <span class="comment">//delmin</span></span><br><span class="line">      v = temp.vertex;</span><br><span class="line">        &#125; <span class="keyword">while</span> (G-&gt;<span class="built_in">getMark</span>(v) == VISITED);</span><br><span class="line"></span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(v, VISITED);  <span class="comment">//mark the vertex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (D[v] == INFINITY) <span class="keyword">return</span>; <span class="comment">//unreachable</span></span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(w=G-&gt;<span class="built_in">first</span>(v); w&lt;G-&gt;<span class="built_in">n</span>(); w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">            <span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w) == UNVISITED)</span><br><span class="line">               <span class="keyword">if</span> (D[w] &gt; (D[v] + G-&gt;<span class="built_in">weight</span>(v, w))) &#123; </span><br><span class="line">                 <span class="comment">//update D      </span></span><br><span class="line">                  D[w] = D[v] + G-&gt;<span class="built_in">weight</span>(v, w);</span><br><span class="line">                  temp.distance = D[w]; temp.vertex = w;</span><br><span class="line">                 <span class="comment">// Insert new distance in heap</span></span><br><span class="line">                  H.<span class="built_in">insert</span>(temp); </span><br><span class="line">               &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>时间复杂度为$\Omega((|V|+|E|)log(|E|))$</p>
<p>多源最短路稀疏图可以跑|V|次Dijkstra，稠密图直接用Floyd就可以</p>
<h5 id="具有负边值的图"><a href="#具有负边值的图" class="headerlink" title="具有负边值的图"></a>具有负边值的图</h5><p>在每一个阶段让一个顶点 v 出队，找出所有邻接到 v 使得$d_{w}&gt;d_{v}+C_{v,w}$的顶点 w，并且更新$d_{w}和 p_{w}$，并在 w 不在队列中的时候将 w 放在队列中<br><strong>Bellman-Ford</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void Graph::wightedNegative ( Vertex s )</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;Vertex&gt; q;</span><br><span class="line">    for each Vertex v</span><br><span class="line">        v.dist = INFINITY;</span><br><span class="line">    s.dist = 0;</span><br><span class="line">    q.enqueue( s );</span><br><span class="line">    while( !q.isEmpty( ) )</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex v = q.dequeue( );</span><br><span class="line">        for each Vertex w adjacent to v</span><br><span class="line">            if( v.dist + cvw &lt; w.dist )</span><br><span class="line">            &#123;</span><br><span class="line">                w.dist = v.dist + cvw;</span><br><span class="line">                w.path = v;</span><br><span class="line">                if (w is not already in q )</span><br><span class="line">                    q.enqueue( w );</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="书上部分习题代码"><a href="#书上部分习题代码" class="headerlink" title="书上部分习题代码"></a>书上部分习题代码</h2><p>Josephus problem 击鼓传花删除人问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i,j, n, m, mPrime, numLeft;</span><br><span class="line">  list &lt;<span class="type">int</span> &gt; L;</span><br><span class="line">  list&lt;<span class="type">int</span>&gt;::iterator iter; </span><br><span class="line"><span class="comment">//Initialization</span></span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;enter N (# of people) &amp; M (# of passes before elimination):&quot;</span>;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">  numLeft = n;</span><br><span class="line">  mPrime = m % n;</span><br><span class="line">  <span class="keyword">for</span> (i =<span class="number">1</span> ; i &lt;= n; i++)</span><br><span class="line">      L.<span class="built_in">push_back</span>(i);</span><br><span class="line">  iter = L.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// Pass the potato</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   mPrime = mPrime % numLeft;</span><br><span class="line">   <span class="keyword">if</span> (mPrime &lt;= numLeft/<span class="number">2</span>) <span class="comment">// pass forward</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mPrime; j++)</span><br><span class="line">      &#123;</span><br><span class="line">iter++;</span><br><span class="line"><span class="keyword">if</span> (iter == L.<span class="built_in">end</span>())</span><br><span class="line">   iter = L.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// pass backward</span></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; mPrime; j++)</span><br><span class="line">      	&#123;</span><br><span class="line">  <span class="keyword">if</span> (iter == L.<span class="built_in">begin</span>())</span><br><span class="line">   iter = --L.<span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   iter--;</span><br><span class="line">    	&#125;</span><br><span class="line">   cout&lt;&lt;*iter&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">   iter= L.<span class="built_in">erase</span>(iter);</span><br><span class="line">   <span class="keyword">if</span> (iter == L.<span class="built_in">end</span>())</span><br><span class="line">      iter = L.<span class="built_in">begin</span>();</span><br><span class="line">   &#125;</span><br><span class="line">  cout&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算后缀表达式的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">evalPostFix</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  stack&lt;<span class="type">double</span>&gt; s;</span><br><span class="line">  string token;</span><br><span class="line">  <span class="type">double</span> a, b, result;</span><br><span class="line">  cin&gt;&gt; token;</span><br><span class="line">  <span class="keyword">while</span> (token[<span class="number">0</span>] != ’=’)</span><br><span class="line">  &#123;</span><br><span class="line">  result = <span class="built_in">atof</span> (token.<span class="built_in">c_str</span>());</span><br><span class="line">  <span class="keyword">if</span> (result != <span class="number">0.0</span> )</span><br><span class="line">     s.<span class="built_in">push</span>(result); </span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&quot;0.0&quot;</span>)</span><br><span class="line">     s.<span class="built_in">push</span>(result);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">switch</span> (token[<span class="number">0</span>])</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">case</span> ’+’ : a = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>(); s.<span class="built_in">push</span>(a+b); <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ’-’ : a = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>(); s.<span class="built_in">push</span>(a-b); <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ’*’ : a = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>(); s.<span class="built_in">push</span>(a*b); <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ’/’ : a = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>(); s.<span class="built_in">push</span>(a/b); <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> ’^’ : a = s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>(); b = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>(); s.<span class="built_in">push</span>(<span class="built_in">exp</span>(a*<span class="built_in">log</span>(b))); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cin&gt;&gt; token; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将中缀表达式转换成后缀表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inToPostfix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">   <span class="type">char</span> token;</span><br><span class="line">   cin&gt;&gt; token;</span><br><span class="line">   <span class="keyword">while</span> (token != ’=’)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="keyword">if</span> (token &gt;= ’a’ &amp;&amp; token &lt;= ’z’)</span><br><span class="line">      cout&lt;&lt;token&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">switch</span> (token)</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">case</span> ’)’ : <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() != ’(’)</span><br><span class="line">                  &#123; cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>; s.<span class="built_in">pop</span>();&#125;</span><br><span class="line">                  s.<span class="built_in">pop</span>(); <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> ’(’ : s.<span class="built_in">push</span>(token); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ’^’ : <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; !(s.<span class="built_in">top</span>()== ’^’ || s.<span class="built_in">top</span>() == ’(’))</span><br><span class="line">                   &#123;cout&lt;&lt;s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();&#125;</span><br><span class="line">                   s.<span class="built_in">push</span>(token); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ’*’ :</span><br><span class="line">        <span class="keyword">case</span> ’/’ : <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() != ’+’ &amp;&amp; s.<span class="built_in">top</span>() != ‘-‘ &amp;&amp; s.<span class="built_in">top</span>() != ‘(‘)</span><br><span class="line">                   &#123;cout&lt;&lt;s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();&#125;</span><br><span class="line">                   s.<span class="built_in">push</span>(token); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ‘+’ :</span><br><span class="line">        <span class="keyword">case</span> ‘-‘ : <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() != ‘(‘ )</span><br><span class="line">                   &#123;cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;’’ ‘‘; s.<span class="built_in">pop</span>();&#125;</span><br><span class="line">                    s.<span class="built_in">push</span>(token); <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cin&gt;&gt; token;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (!s.<span class="built_in">empty</span>())</span><br><span class="line">      &#123;cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;’’ ‘‘; s.<span class="built_in">pop</span>();&#125;</span><br><span class="line">   cout&lt;&lt;ˇ = \nˇ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用一个数组实现两个栈可以</p>
<ul>
<li>让一个栈从数组的左边向右边递增增长</li>
<li>另一个栈从数组的右边向左边递减增长</li>
</ul>
<p>双端队列的实现（其实就是将list包装了一下）</p>
<p>list是一个双向循环列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">This <span class="keyword">requires</span> a doubly linked list with pointers to the head <span class="keyword">and</span> the tail In fact it can be implemented</span><br><span class="line">with a list by just renaming the list operations.</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Object&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">deque</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">deque</span>() &#123; <span class="built_in">l</span>();&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span> <span class="params">(Object obj)</span> </span>&#123;l.<span class="built_in">push_front</span>(obj);&#125;</span><br><span class="line">  <span class="function">Object <span class="title">pop</span> <span class="params">()</span></span>; &#123;Object obj=l.<span class="built_in">front</span>(); l.<span class="built_in">pop_front</span>(); <span class="keyword">return</span> obj;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">inject</span><span class="params">(Object obj)</span></span>; &#123;l.<span class="built_in">push_back</span>(obj);&#125;</span><br><span class="line">  <span class="function">Object <span class="title">eject</span><span class="params">()</span></span>; &#123;<span class="built_in">pop_back</span>(obj);&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  list&lt;Object&gt; l;</span><br><span class="line">&#125;; <span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自调整表的数组和链表实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* A;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> Max;</span><br><span class="line">&#125;*List,List1;<span class="comment">//qnode,*pnode;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L-&gt;A=(<span class="type">int</span>*)<span class="built_in">malloc</span>(MAX*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L-&gt;Max=MAX;</span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;Max;i++)</span><br><span class="line">        L-&gt;A[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(List L,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;Max&lt;=L-&gt;length)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;out of space!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;A[<span class="number">0</span>]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;A[<span class="number">0</span>]=x;</span><br><span class="line">            L-&gt;length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=L-&gt;length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//把所有数字往后移动一个位置</span></span><br><span class="line">                L-&gt;A[i<span class="number">+1</span>]=L-&gt;A[i];</span><br><span class="line">            L-&gt;A[<span class="number">0</span>]=x;</span><br><span class="line">            L-&gt;length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,L-&gt;A[i]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Find</span><span class="params">(List L,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;A[i]!=x&amp;&amp;L-&gt;A[i]!=<span class="number">-1</span>)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;A[i]==x)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            L-&gt;A[j]=L-&gt;A[j<span class="number">-1</span>];</span><br><span class="line">        L-&gt;A[<span class="number">0</span>]=x; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;out of space!&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List1 L;</span><br><span class="line">    <span class="built_in">init</span>(&amp;L);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(&amp;L,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">Find</span>(&amp;L,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Find</span>(&amp;L,<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(&amp;L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> *PtrToNode;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode Position;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Element;</span><br><span class="line">    Position next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">List <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    L=(List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(List L,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position pos,head;</span><br><span class="line">    head=L;</span><br><span class="line">    pos=(List)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    pos-&gt;Element=x;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next=pos;</span><br><span class="line">        pos-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pos-&gt;next=head-&gt;next;</span><br><span class="line">        head-&gt;next=pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(List L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position pos=L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(pos!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,pos-&gt;Element);</span><br><span class="line">        pos=pos-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">FindPrevious</span><span class="params">(List L,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position pos;</span><br><span class="line">    pos=L;</span><br><span class="line">    <span class="keyword">while</span>(pos-&gt;next!=<span class="literal">NULL</span>&amp;&amp;pos-&gt;next-&gt;Element!=x)</span><br><span class="line">        pos=pos-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(List L,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Position pos,head,previous;</span><br><span class="line">    head=L;</span><br><span class="line">    previous=<span class="built_in">FindPrevious</span>(L,x);</span><br><span class="line">    <span class="keyword">if</span>(previous-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	    pos=previous-&gt;next;</span><br><span class="line">	    previous-&gt;next=pos-&gt;next;</span><br><span class="line">	    pos-&gt;next=head-&gt;next;</span><br><span class="line">	    head-&gt;next=pos;</span><br><span class="line">	    <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    L=<span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">Insert</span>(L,<span class="number">6</span>);</span><br><span class="line">    L=<span class="built_in">Find</span>(L,<span class="number">2</span>);</span><br><span class="line">    L=<span class="built_in">Find</span>(L,<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="王道考研真题复习"><a href="#王道考研真题复习" class="headerlink" title="王道考研真题复习"></a>王道考研真题复习</h2><h3 id="1-算法与算法评价"><a href="#1-算法与算法评价" class="headerlink" title="1.算法与算法评价"></a>1.算法与算法评价</h3><p>算法原地工作的含义是所需的辅助空间是常数</p>
<p><strong>在相同规模的n下$O(n)$的算法在时间上总是优于复杂度为$O(2^{N})$的算法</strong></p>
<ul>
<li>因为时间复杂度指的是渐进时间复杂度，不要去为n赋予特殊值</li>
</ul>
<p>假设$T(n)&#x3D;\begin{cases} 1&amp; \text{n&#x3D;1} \ 2T(n&#x2F;2)+n &amp; \text{n&gt;1}\end{cases} $</p>
<p>设n是2的正整数次幂</p>
<p>解:假设n&#x3D;$2^{k}$,则$T(2^{k})&#x3D;2T(2^{k-1})+2^{k}&#x3D;2^{k}T(2^{0})+k<em>2^{k}&#x3D;2^{k}</em>(k+1)$</p>
<p>显然是$O(nlog_{2}n)$级别的</p>
<h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h3><p>线性表中除最后一个&#x2F;第一个元素之外,每个元素都只有一个前驱&#x2F;后继元素</p>
<p>在带头结点L的链表中删除一个最小值节点的算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList Delete <span class="title">Min</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="comment">//1是带头结点的单链表，本算法删除其最小值结点</span></span><br><span class="line">INode *pre=L，*p=pre-&gt;next;<span class="comment">//p为工作指针，pze指向其前驱</span></span><br><span class="line">    LNode *minpre=pre,*minp=p;<span class="comment">//保存最小值结点及其前驱</span></span><br><span class="line">    <span class="keyword">while</span>(p!-<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;data&lt;minp-&gt;data)&#123;</span><br><span class="line">			minp=p;<span class="comment">//找到比之前找到的最小值结点更小的结点</span></span><br><span class="line">			minpre=pre;</span><br><span class="line">    	&#125;</span><br><span class="line">		pre=p;</span><br><span class="line">		p=p-&gt;next;<span class="comment">//继续扫描下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">    minpre-&gt;next=minp-&gt;next;<span class="comment">//剥除最小值结点</span></span><br><span class="line">	<span class="built_in">free</span>(minp);</span><br><span class="line">	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog">i6bimua</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://i6biua.github.io/blog/2024/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/">https://i6biua.github.io/blog/2024/10/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://i6biua.github.io/blog" target="_blank">i6bimua</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">数据结构与算法分析</a><a class="post-meta__tags" href="/blog/tags/%E5%A4%8D%E4%B9%A0/">复习</a></div><div class="post_share"><div class="social-share" data-image="/blog/img/mitsuha.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2024/11/01/LEETCODE3259/" title="LEETCODE3259"><img class="cover" src="/blog/img/bg.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">LEETCODE3259</div></div></a></div><div class="next-post pull-right"><a href="/blog/2024/10/29/LEETCODE3211/" title="LEETCODE3211"><img class="cover" src="/blog/img/ayanami.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LEETCODE3211</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2024/10/28/%E8%AE%A1%E7%BB%84%E8%AF%95%E9%A2%98/" title="计组试题"><img class="cover" src="/blog/img/bg2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-28</div><div class="title">计组试题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/blog/img/avatar.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">i6bimua</div><div class="author-info__description">天有雨</div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/i6biua"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">天有雨</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">第 2 章 算法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E5%9F%BA%E7%A1%80-ADT"><span class="toc-number">2.</span> <span class="toc-text">第 3 章 基础 ADT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-List"><span class="toc-number">2.1.</span> <span class="toc-text">3.5 List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Array-Implementation"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">Array Implementation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pointer-Implementation"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">Pointer Implementation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Comparison-of-List-Implementations"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">Comparison of List Implementations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Stack"><span class="toc-number">2.2.</span> <span class="toc-text">3.6 Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">计算后缀表达式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E5%88%B0%E5%90%8E%E7%BC%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">中缀到后缀的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">数组实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">链表实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-Queue"><span class="toc-number">2.3.</span> <span class="toc-text">3.7 Queue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-Tree"><span class="toc-number">3.</span> <span class="toc-text">第 4 章 Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%B8%80%E6%A3%B5%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91"><span class="toc-number">3.0.0.0.1.</span> <span class="toc-text">构造一棵表达式树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">4.3 二叉查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-remove"><span class="toc-number">3.1.1.</span> <span class="toc-text">4.3.4 remove</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-AVL-%E6%A0%91"><span class="toc-number">3.2.</span> <span class="toc-text">4.4 AVL 树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E5%8D%95%E6%97%8B%E8%BD%AC"><span class="toc-number">3.2.1.</span> <span class="toc-text">4.4.1 单旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-splay"><span class="toc-number">3.3.</span> <span class="toc-text">4.5 splay</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%B1%95%E5%BC%80"><span class="toc-number">3.3.1.</span> <span class="toc-text">4.5.2  展开</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-B-Tree"><span class="toc-number">3.4.</span> <span class="toc-text">4.7 B-Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Delete-x"><span class="toc-number">3.4.0.0.1.</span> <span class="toc-text">Delete x</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E6%95%A3%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">第 5 章 散列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%88%86%E7%A6%BB%E9%93%BE%E6%8E%A5%E6%B3%95-separate-chaining"><span class="toc-number">4.1.</span> <span class="toc-text">5.3 分离链接法 separate chaining</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E4%B8%8D%E7%94%A8%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8-Open-Addressing"><span class="toc-number">4.2.</span> <span class="toc-text">5.4 不用链表的散列表 Open Addressing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">5.4.1 线性探测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peseudo-random-probing"><span class="toc-number">4.2.2.</span> <span class="toc-text">Peseudo-random probing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95-Quadratic-Probing"><span class="toc-number">4.2.3.</span> <span class="toc-text">5.4.2 平方探测法 Quadratic Probing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E5%8F%8C%E6%95%A3%E5%88%97-double-hashing"><span class="toc-number">4.2.4.</span> <span class="toc-text">5.4.3 双散列 double hashing</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%86%8D%E6%95%A3%E5%88%97"><span class="toc-number">4.3.</span> <span class="toc-text">5.5 再散列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-%E5%A0%86"><span class="toc-number">5.</span> <span class="toc-text">第 6 章 优先队列&#x2F;堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">5.1.</span> <span class="toc-text">6.3 二叉堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E7%BB%93%E6%9E%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">6.3.1 结构性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%A0%86%E5%BA%8F%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">6.3.2 堆序性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%A0%86%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.3.</span> <span class="toc-text">6.3.3 基本的堆操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-4-%E5%85%B6%E4%BB%96%E7%9A%84%E5%A0%86%E6%93%8D%E4%BD%9C"><span class="toc-number">5.1.4.</span> <span class="toc-text">6.3.4 其他的堆操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">第 7 章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">稳定性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">6.3.</span> <span class="toc-text">7.2 插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">插入排序的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%8B%E7%95%8C"><span class="toc-number">6.4.</span> <span class="toc-text">7.3 一些简单排序算法的下界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-7-1-N-%E4%B8%AA%E4%BA%92%E5%BC%82%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E5%9D%87%E9%80%86%E5%BA%8F%E6%95%B0%E6%98%AF-N-N-1-4"><span class="toc-number">6.4.1.</span> <span class="toc-text">定理 7.1  N 个互异元素的数组的平均逆序数是 $N(N-1)&#x2F;4$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-7-2-%E9%80%9A%E8%BF%87%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%BB%E4%BD%95%E7%AE%97%E6%B3%95%E5%B9%B3%E5%9D%87%E9%83%BD%E9%9C%80%E8%A6%81-Omega-N-2-%E6%97%B6%E9%97%B4"><span class="toc-number">6.4.2.</span> <span class="toc-text">定理 7.2.通过交换相邻元素进行排序的任何算法平均都需要$\Omega(N^{2})$时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-diminishing-increment-sort%EF%BC%88%E7%BC%A9%E5%87%8F%E5%A2%9E%E9%87%8F%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">7.4 希尔排序 diminishing increment sort（缩减增量排序）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%90%86-7-3-%E4%BD%BF%E7%94%A8%E5%B8%8C%E5%B0%94%E5%A2%9E%E9%87%8F%E6%97%B6%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%9D%8F%E6%83%85%E5%BD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%B8%BA-Omega-N-2"><span class="toc-number">6.5.1.</span> <span class="toc-text">定理 7.3 使用希尔增量时希尔排序的最坏情形运行时间为$\Omega(N^{2})$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hibbard-%E5%A2%9E%E9%87%8F%E5%BA%8F%E5%88%97%EF%BC%9A1%EF%BC%8C3%EF%BC%8C7%EF%BC%8C%E2%80%A6%EF%BC%8C-2-k-1"><span class="toc-number">6.5.2.</span> <span class="toc-text">Hibbard 增量序列：1，3，7，…，$2^{k}-1$</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Hibbard-%E5%A2%9E%E9%87%8F%E7%9A%84%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%9D%8F%E6%83%85%E5%BD%A2%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%98%AF-Omega-N-2"><span class="toc-number">6.5.3.</span> <span class="toc-text">使用 Hibbard 增量的希尔排序的最坏情形运行时间是$\Omega(N^{2})$</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%A0%86%E6%8E%92%E5%BA%8F-heapsort"><span class="toc-number">6.6.</span> <span class="toc-text">7.5 堆排序 heapsort</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.6.0.1.</span> <span class="toc-text">堆排序的性质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.7.</span> <span class="toc-text">7.6 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">6.7.0.1.</span> <span class="toc-text">归并排序的分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.8.</span> <span class="toc-text">7.7 快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.8.0.1.</span> <span class="toc-text">快速排序的性质</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-6-%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E7%BA%BF%E6%80%A7%E6%9C%9F%E6%9C%9B%E6%97%B6%E9%97%B4%E7%AE%97%E6%B3%95"><span class="toc-number">6.8.1.</span> <span class="toc-text">7.7.6 选择问题的线性期望时间算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">6.9.</span> <span class="toc-text">7.8 桶排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-radix-sort"><span class="toc-number">6.10.</span> <span class="toc-text">7.9 基数排序 radix sort</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Radix-Sort-%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.10.0.0.1.</span> <span class="toc-text">Radix Sort 的性质</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%8B%E7%95%8C"><span class="toc-number">6.11.</span> <span class="toc-text">7.10 排序问题的下界</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8B%E7%95%8C"><span class="toc-number">6.11.0.1.</span> <span class="toc-text">选择问题的决策树下界</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E7%AC%AC-k-%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97%E9%9C%80%E8%A6%81-N-k-lceil-log-binom-N-k-1-rceil"><span class="toc-number">6.11.0.1.1.</span> <span class="toc-text">找到第 k 小的数字需要 N-k+$\lceil log \binom{N}{k-1} \rceil$</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E7%AC%AC-k-%E5%B0%8F%E5%85%83%E7%B4%A0%E7%9A%84%E5%86%B3%E7%AD%96%E6%A0%91%E8%87%B3%E5%B0%91%E6%9C%89-binom-N-k-1-2-N-k-%E4%B8%AA%E6%A0%91%E5%8F%B6"><span class="toc-number">6.11.0.1.2.</span> <span class="toc-text">找到第 k 小元素的决策树至少有 $\binom{N}{k-1}2^{N-k}$个树叶</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F-External-Sorting"><span class="toc-number">6.12.</span> <span class="toc-text">7.11 外部排序 External Sorting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Replacement-selection"><span class="toc-number">6.12.0.1.</span> <span class="toc-text">Replacement selection</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%B1%BB%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">第 8 章 不相交集类（并查集）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%90%88%E5%B9%B6%EF%BC%9A%E4%BD%BF%E7%AC%AC%E4%BA%8C%E6%A3%B5%E6%A0%91%E6%88%90%E4%B8%BA%E7%AC%AC%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">7.0.1.</span> <span class="toc-text">任意合并：使第二棵树成为第一棵树的子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union-by-size-%E5%B0%86%E5%A4%A7%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%A0%91%E5%90%88%E5%B9%B6%E5%88%B0%E5%A4%A7%E5%B0%8F%E8%BE%83%E5%A4%A7%E7%9A%84%E6%A0%91%E4%B8%8A"><span class="toc-number">7.0.2.</span> <span class="toc-text">union by size 将大小小的树合并到大小较大的树上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#union-by-height-rank-%E4%BD%BF%E5%BE%97%E9%AB%98%E5%BA%A6%E8%BE%83%E5%B0%8F%E7%9A%84%E6%A0%91%E6%88%90%E4%B8%BA%E9%AB%98%E5%BA%A6%E8%BE%83%E9%AB%98%E7%9A%84%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">7.0.3.</span> <span class="toc-text">union by height&#x2F;rank 使得高度较小的树成为高度较高的树的子树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9"><span class="toc-number">7.0.4.</span> <span class="toc-text">路径压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">第 9 章 图论算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">9.1 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">9.2 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">9.3 最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%A0%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88BFS%EF%BC%89"><span class="toc-number">8.3.0.1.</span> <span class="toc-text">无权最短路径（BFS）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.0.2.</span> <span class="toc-text">Dijkstra 算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">8.3.1.</span> <span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Topological-Sort"><span class="toc-number">8.3.2.</span> <span class="toc-text">Topological Sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shortest-Path-Algorithms"><span class="toc-number">8.3.3.</span> <span class="toc-text">Shortest-Path Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dijkstra"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E8%B4%9F%E8%BE%B9%E5%80%BC%E7%9A%84%E5%9B%BE"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">具有负边值的图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E4%B8%8A%E9%83%A8%E5%88%86%E4%B9%A0%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="toc-number">9.</span> <span class="toc-text">书上部分习题代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%E7%9C%9F%E9%A2%98%E5%A4%8D%E4%B9%A0"><span class="toc-number">10.</span> <span class="toc-text">王道考研真题复习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">10.1.</span> <span class="toc-text">1.算法与算法评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2.线性表</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML"><img src="/blog/img/kon.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="hungyi_Lee_ML"/></a><div class="content"><a class="title" href="/blog/2025/04/20/hungyi-Lee-ML/" title="hungyi_Lee_ML">hungyi_Lee_ML</a><time datetime="2025-04-20T14:04:16.000Z" title="发表于 2025-04-20 22:04:16">2025-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258"><img src="/blog/img/bg.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3258"/></a><div class="content"><a class="title" href="/blog/2024/11/12/LEETCODE3258/" title="LEETCODE3258">LEETCODE3258</a><time datetime="2024-11-12T14:18:13.000Z" title="发表于 2024-11-12 22:18:13">2024-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE540"/></a><div class="content"><a class="title" href="/blog/2024/11/10/LEETCODE540/" title="LEETCODE540">LEETCODE540</a><time datetime="2024-11-10T01:49:46.000Z" title="发表于 2024-11-10 09:49:46">2024-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255"><img src="/blog/img/kabuto.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3255"/></a><div class="content"><a class="title" href="/blog/2024/11/06/LEETCODE3255/" title="LEETCODE3255">LEETCODE3255</a><time datetime="2024-11-06T01:36:01.000Z" title="发表于 2024-11-06 09:36:01">2024-11-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222"><img src="/blog/img/raingirl.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="LEETCODE3222"/></a><div class="content"><a class="title" href="/blog/2024/11/05/LEETCODE3222/" title="LEETCODE3222">LEETCODE3222</a><time datetime="2024-11-05T04:57:18.000Z" title="发表于 2024-11-05 12:57:18">2024-11-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By i6bimua</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>